import{S as R,a as o,b as C,c as O,d as S,e as D,f as k,g as w,h as U,i as M,j as z,k as y,l as L,m as T,n as j,o as Q,p as V,q as B,r as H,s as q,t as W,u as I,v as K,w as G,x as $,y as Y,z as X,A as Z,B as J,C as ee,D as te,E as v,F as se,G as re}from"./WASQLiteDB.worker-B8dbDqHc.js";const ne=512;class ae{name;mxPathname=64;_module;constructor(e,t){this.name=e,this._module=t}close(){}isReady(){return!0}hasAsyncMethod(e){return!1}xOpen(e,t,s,r,n){return R}xDelete(e,t,s){return o}xAccess(e,t,s,r){return o}xFullPathname(e,t,s,r){return o}xGetLastError(e,t,s){return o}xClose(e){return o}xRead(e,t,s,r,n){return o}xWrite(e,t,s,r,n){return o}xTruncate(e,t,s){return o}xSync(e,t){return o}xFileSize(e,t){return o}xLock(e,t){return o}xUnlock(e,t){return o}xCheckReservedLock(e,t){return o}xFileControl(e,t,s){return C}xSectorSize(e){return ne}xDeviceCharacteristics(e){return 0}}const ie=Object.getPrototypeOf(async function(){}).constructor;class oe extends ae{constructor(e,t){super(e,t)}hasAsyncMethod(e){const t=`j${e.slice(1)}`;return this[t]instanceof ie}getFilename(e){throw new Error("unimplemented")}jOpen(e,t,s,r){return R}jDelete(e,t){return o}jAccess(e,t,s){return o}jFullPathname(e,t){const{read:s,written:r}=new TextEncoder().encodeInto(e,t);return s<e.length?O:r>=t.length?O:(t[r]=0,o)}jGetLastError(e){return o}jClose(e){return o}jRead(e,t,s){return t.fill(0),S}jWrite(e,t,s){return D}jTruncate(e,t){return o}jSync(e,t){return o}jFileSize(e,t){return o}jLock(e,t){return o}jUnlock(e,t){return o}jCheckReservedLock(e,t){return t.setInt32(0,0,!0),o}jFileControl(e,t,s){return C}jSectorSize(e){return super.xSectorSize(e)}jDeviceCharacteristics(e){return 0}xOpen(e,t,s,r,n){const i=this.#n(t,r),a=this.#t("Int32",n);return this.log?.("jOpen",i,s,"0x"+r.toString(16)),this.jOpen(i,s,r,a)}xDelete(e,t,s){const r=this._module.UTF8ToString(t);return this.log?.("jDelete",r,s),this.jDelete(r,s)}xAccess(e,t,s,r){const n=this._module.UTF8ToString(t),i=this.#t("Int32",r);return this.log?.("jAccess",n,s),this.jAccess(n,s,i)}xFullPathname(e,t,s,r){const n=this._module.UTF8ToString(t),i=this._module.HEAPU8.subarray(r,r+s);return this.log?.("jFullPathname",n,s),this.jFullPathname(n,i)}xGetLastError(e,t,s){const r=this._module.HEAPU8.subarray(s,s+t);return this.log?.("jGetLastError",t),this.jGetLastError(r)}xClose(e){return this.log?.("jClose",e),this.jClose(e)}xRead(e,t,s,r,n){const i=this.#e(t,s),a=x(r,n);return this.log?.("jRead",e,s,a),this.jRead(e,i,a)}xWrite(e,t,s,r,n){const i=this.#e(t,s),a=x(r,n);return this.log?.("jWrite",e,i,a),this.jWrite(e,i,a)}xTruncate(e,t,s){const r=x(t,s);return this.log?.("jTruncate",e,r),this.jTruncate(e,r)}xSync(e,t){return this.log?.("jSync",e,t),this.jSync(e,t)}xFileSize(e,t){const s=this.#t("BigInt64",t);return this.log?.("jFileSize",e),this.jFileSize(e,s)}xLock(e,t){return this.log?.("jLock",e,t),this.jLock(e,t)}xUnlock(e,t){return this.log?.("jUnlock",e,t),this.jUnlock(e,t)}xCheckReservedLock(e,t){const s=this.#t("Int32",t);return this.log?.("jCheckReservedLock",e),this.jCheckReservedLock(e,s)}xFileControl(e,t,s){const r=new DataView(this._module.HEAPU8.buffer,this._module.HEAPU8.byteOffset+s);return this.log?.("jFileControl",e,t,r),this.jFileControl(e,t,r)}xSectorSize(e){return this.log?.("jSectorSize",e),this.jSectorSize(e)}xDeviceCharacteristics(e){return this.log?.("jDeviceCharacteristics",e),this.jDeviceCharacteristics(e)}#t(e,t){const s=e==="Int32"?4:8,r=`get${e}`,n=`set${e}`,i=()=>new DataView(this._module.HEAPU8.buffer,this._module.HEAPU8.byteOffset+t,s);let a=i();return new Proxy(a,{get(l,c){if(a.buffer.byteLength===0&&(a=i()),c===r)return function(h,u){if(!u)throw new Error("must be little endian");return a[c](h,u)};if(c===n)return function(h,u,f){if(!f)throw new Error("must be little endian");return a[c](h,u,f)};if(typeof c=="string"&&c.match(/^(get)|(set)/))throw new Error("invalid type");const d=a[c];return typeof d=="function"?d.bind(a):d}})}#e(e,t){let s=this._module.HEAPU8.subarray(e,e+t);return new Proxy(s,{get:(r,n,i)=>{s.buffer.byteLength===0&&(s=this._module.HEAPU8.subarray(e,e+t));const a=s[n];return typeof a=="function"?a.bind(s):a}})}#n(e,t){if(t&k){let s=e,r=1;const n=[];for(;r;){const i=this._module.HEAPU8[s++];if(i)n.push(i);else switch(this._module.HEAPU8[s]||(r=null),r){case 1:n.push(63),r=2;break;case 2:n.push(61),r=3;break;case 3:n.push(38),r=2;break}}return new TextDecoder().decode(new Uint8Array(n))}return e?this._module.UTF8ToString(e):null}}function x(g,e){return e*4294967296+g+(g<0?2**32:0)}const b={mode:"shared"},ce={ifAvailable:!0,mode:"shared"},A={ifAvailable:!0,mode:"exclusive"},le=["exclusive","shared","shared+hint"],_=g=>class extends g{#t={lockPolicy:"exclusive",lockTimeout:1/0};#e=new Map;constructor(e,t,s){if(super(e,t,s),Object.assign(this.#t,s),le.indexOf(this.#t.lockPolicy)===-1)throw new Error(`WebLocksMixin: invalid lock mode: ${s.lockPolicy}`)}async jLock(e,t){try{if(!this.#e.has(e)){const n={baseName:this.getFilename(e),type:w,writeHint:!1};this.#e.set(e,n)}const s=this.#e.get(e);if(t<=s.type)return o;switch(this.#t.lockPolicy){case"exclusive":return await this.#n(s,t);case"shared":case"shared+hint":return await this.#i(s,t)}}catch(s){return console.error("WebLocksMixin: lock error",s),U}}async jUnlock(e,t){try{const s=this.#e.get(e);if(t>=s.type)return o;switch(this.#t.lockPolicy){case"exclusive":return await this.#r(s,t);case"shared":case"shared+hint":return await this.#o(s,t)}}catch(s){return console.error("WebLocksMixin: unlock error",s),M}}async jCheckReservedLock(e,t){try{const s=this.#e.get(e);switch(this.#t.lockPolicy){case"exclusive":return this.#a(s,t);case"shared":case"shared+hint":return await this.#c(s,t)}}catch(s){return console.error("WebLocksMixin: check reserved lock error",s),z}return t.setInt32(0,0,!0),o}jFileControl(e,t,s){const r=this.#e.get(e)??(this.jLock(e,w),this.#e.get(e));return t===_.WRITE_HINT_OP_CODE&&this.#t.lockPolicy==="shared+hint"&&(r.writeHint=!0),C}async#n(e,t){if(!e.access){if(!await this.#s(e,"access"))return y;console.assert(!!e.access)}return e.type=t,o}#r(e,t){return t===w&&(e.access?.(),console.assert(!e.access)),e.type=t,o}#a(e,t){return t.setInt32(0,0,!0),o}async#i(e,t){switch(e.type){case w:switch(t){case j:if(e.writeHint&&!await this.#s(e,"hint"))return y;if(!await this.#s(e,"gate",b))return e.hint?.(),y;await this.#s(e,"access",b),e.gate(),console.assert(!e.gate),console.assert(!!e.access),console.assert(!e.reserved);break;default:throw new Error("unsupported lock transition")}break;case j:switch(t){case L:if(this.#t.lockPolicy==="shared+hint"&&!e.hint&&!await this.#s(e,"hint",A))return y;if(!await this.#s(e,"reserved",A))return e.hint?.(),y;e.access(),console.assert(!e.gate),console.assert(!e.access),console.assert(!!e.reserved);break;case T:if(!await this.#s(e,"gate"))return y;if(e.access(),!await this.#s(e,"access"))return e.gate(),y;console.assert(!!e.gate),console.assert(!!e.access),console.assert(!e.reserved);break;default:throw new Error("unsupported lock transition")}break;case L:switch(t){case T:if(!await this.#s(e,"gate"))return y;if(!await this.#s(e,"access"))return e.gate(),y;console.assert(!!e.gate),console.assert(!!e.access),console.assert(!!e.reserved);break;default:throw new Error("unsupported lock transition")}break}return e.type=t,o}async#o(e,t){if(t===w)e.access?.(),e.gate?.(),e.reserved?.(),e.hint?.(),e.writeHint=!1,console.assert(!e.access),console.assert(!e.gate),console.assert(!e.reserved),console.assert(!e.hint);else switch(e.type){case T:e.access(),await this.#s(e,"access",b),e.gate(),e.reserved?.(),e.hint?.(),console.assert(!!e.access),console.assert(!e.gate),console.assert(!e.reserved);break;case L:await this.#s(e,"access",b),e.reserved(),e.hint?.(),console.assert(!!e.access),console.assert(!e.gate),console.assert(!e.reserved);break}return e.type=t,o}async#c(e,t){return await this.#s(e,"reserved",ce)?(e.reserved(),t.setInt32(0,0,!0)):t.setInt32(0,1,!0),o}#s(e,t,s={}){return console.assert(!e[t]),new Promise(r=>{if(!s.ifAvailable&&this.#t.lockTimeout<1/0){const i=new AbortController;s=Object.assign({},s,{signal:i.signal}),setTimeout(()=>{i.abort(),r?.(!1)},this.#t.lockTimeout)}const n=`lock##${e.baseName}##${t}`;navigator.locks.request(n,s,i=>{if(i)return new Promise(a=>{e[t]=()=>{a(),e[t]=null},r(!0),r=null});e[t]=null,r(!1),r=null}).catch(i=>{if(i.name!=="AbortError")throw i})})}};_.WRITE_HINT_OP_CODE=-9999;class ue{path;flags;metadata;fileSize=0;needsMetadataSync=!1;rollback=null;changedPages=new Set;synchronous="full";txOptions={durability:"strict"};constructor(e,t,s){this.path=e,this.flags=t,this.metadata=s}}class N extends _(oe){mapIdToFile=new Map;lastError=null;log=null;#t;#e;static async create(e,t,s){const r=new N(e,t,s);return await r.isReady(),r}constructor(e,t,s={}){super(e,t,s),this.#t=this.#n(s.idbName??e)}async#n(e){this.#e=await F.create(e)}close(){this.#e.close()}async isReady(){await super.isReady(),await this.#t}getFilename(e){const t=this.mapIdToFile.get(e).path;return`IDB(${this.name}):${t}`}async jOpen(e,t,s,r){try{const i=new URL(e||Math.random().toString(36).slice(2),"file://").pathname;let a=await this.#e.q(({metadata:c})=>c.get(i));if(!a&&s&Q&&(a={name:i,fileSize:0,version:0},await this.#e.q(({metadata:c})=>c.put(a),"rw")),!a)throw new Error(`File ${i} not found`);const l=new ue(i,s,a);return this.mapIdToFile.set(t,l),r.setInt32(0,s,!0),o}catch(n){return this.lastError=n,R}}async jDelete(e,t){try{const r=new URL(e,"file://").pathname;return this.#e.q(({metadata:n,blocks:i})=>{const a=IDBKeyRange.bound([r,-1/0],[r,1/0]);i.delete(a),n.delete(r)},"rw"),t&&await this.#e.sync(!1),o}catch(s){return this.lastError=s,V}}async jAccess(e,t,s){try{const n=new URL(e,"file://").pathname,i=await this.#e.q(({metadata:a})=>a.get(n));return s.setInt32(0,i?1:0,!0),o}catch(r){return this.lastError=r,B}}async jClose(e){try{const t=this.mapIdToFile.get(e);return this.mapIdToFile.delete(e),t.flags&H&&await this.#e.q(({metadata:s,blocks:r})=>{s.delete(t.path),r.delete(IDBKeyRange.bound([t.path,0],[t.path,1/0]))},"rw"),t.needsMetadataSync&&this.#e.q(({metadata:s})=>s.put(t.metadata),"rw"),await this.#e.sync(t.synchronous==="full"),o}catch(t){return this.lastError=t,q}}async jRead(e,t,s){try{const r=this.mapIdToFile.get(e);let n=0;for(;n<t.byteLength;){const i=s+n,a=await this.#e.q(({blocks:h})=>{const u=IDBKeyRange.bound([r.path,-i],[r.path,1/0]);return h.get(u)});if(!a||a.data.byteLength-a.offset<=i)return t.fill(0,n),S;const l=t.subarray(n),c=i+a.offset,d=Math.min(Math.max(a.data.byteLength-c,0),l.byteLength);l.set(a.data.subarray(c,c+d)),n+=d}return o}catch(r){return this.lastError=r,W}}jWrite(e,t,s){try{const r=this.mapIdToFile.get(e);if(r.flags&I&&!r.rollback){const l=Object.assign({pendingVersion:r.metadata.version-1},r.metadata);this.#e.q(({metadata:c})=>c.put(l),"rw",r.txOptions),r.rollback=Object.assign({},r.metadata),r.metadata.version--}r.flags&I&&r.changedPages.add(s);const n=t.slice(),i=r.metadata.version;if(!(s<r.metadata.fileSize)||r.flags&I||r.flags&K){const l={path:r.path,offset:-s,version:i,data:t.slice()};this.#e.q(({blocks:c})=>{c.put(l),r.changedPages.add(s)},"rw",r.txOptions)}else this.#e.q(async({blocks:l})=>{const c=IDBKeyRange.bound([r.path,-s],[r.path,1/0]),d=await l.get(c);d.data.subarray(s+d.offset).set(n),l.put(d)},"rw",r.txOptions);return r.metadata.fileSize<s+t.length&&(r.metadata.fileSize=s+t.length,r.needsMetadataSync=!0),o}catch(r){return this.lastError=r,D}}jTruncate(e,t){try{const s=this.mapIdToFile.get(e);return t<s.metadata.fileSize&&(this.#e.q(({blocks:r})=>{const n=IDBKeyRange.bound([s.path,-1/0],[s.path,-t,1/0]);r.delete(n)},"rw",s.txOptions),s.metadata.fileSize=t,s.needsMetadataSync=!0),o}catch(s){return this.lastError=s,G}}async jSync(e,t){try{const s=this.mapIdToFile.get(e);return s.needsMetadataSync&&(this.#e.q(({metadata:r})=>r.put(s.metadata),"rw",s.txOptions),s.needsMetadataSync=!1),s.flags&I?s.synchronous==="full"&&await this.#e.sync(!0):await this.#e.sync(s.synchronous==="full"),o}catch(s){return this.lastError=s,$}}jFileSize(e,t){try{const s=this.mapIdToFile.get(e);return t.setBigInt64(0,BigInt(s.metadata.fileSize),!0),o}catch(s){return this.lastError=s,Y}}async jLock(e,t){const s=this.mapIdToFile.get(e),r=await super.jLock(e,t);return t===j&&(s.metadata=await this.#e.q(async({metadata:n,blocks:i})=>{const a=await n.get(s.path);return a.pendingVersion&&(console.warn(`removing failed transaction ${a.pendingVersion}`),await new Promise((l,c)=>{const d=IDBKeyRange.bound([a.name,-1/0],[a.name,1/0]),h=i.openCursor(d);h.onsuccess=()=>{const u=h.result;u?(u.value.version<a.version&&u.delete(),u.continue()):l()},h.onerror=()=>c(h.error)}),delete a.pendingVersion,n.put(a)),a},"rw",s.txOptions)),r}async jUnlock(e,t){if(t===w){const s=this.mapIdToFile.get(e);await this.#e.sync(s.synchronous==="full")}return super.jUnlock(e,t)}jFileControl(e,t,s){try{const r=this.mapIdToFile.get(e);switch(t){case te:const n=P(s,4),i=P(s,8);this.log?.("xFileControl",r.path,"PRAGMA",n,i);const a=h=>{const u=new TextEncoder().encode(h),f=this._module._sqlite3_malloc(u.byteLength);return this._module.HEAPU8.subarray(f,f+u.byteLength).set(u),s.setUint32(0,f,!0),v};switch(n.toLowerCase()){case"page_size":if(r.flags&I&&i&&r.metadata.fileSize)return v;break;case"synchronous":if(i)switch(i.toLowerCase()){case"0":case"off":r.synchronous="off",r.txOptions={durability:"relaxed"};break;case"1":case"normal":r.synchronous="normal",r.txOptions={durability:"relaxed"};break;case"2":case"3":case"full":case"extra":r.synchronous="full",r.txOptions={durability:"strict"};break}break;case"write_hint":return super.jFileControl(e,_.WRITE_HINT_OP_CODE,null)}break;case ee:this.log?.("xFileControl",r.path,"SYNC");const l=Object.assign({},r.metadata),c=r.rollback.fileSize;this.#e.q(({metadata:h,blocks:u})=>{h.put(l);for(const f of r.changedPages)if(f<c){const p=IDBKeyRange.bound([r.path,-f,l.version],[r.path,-f,1/0],!0);u.delete(p)}r.changedPages.clear()},"rw",r.txOptions),r.needsMetadataSync=!1,r.rollback=null;break;case J:return this.log?.("xFileControl",r.path,"BEGIN_ATOMIC_WRITE"),o;case Z:return this.log?.("xFileControl",r.path,"COMMIT_ATOMIC_WRITE"),o;case X:this.log?.("xFileControl",r.path,"ROLLBACK_ATOMIC_WRITE"),r.metadata=r.rollback;const d=Object.assign({},r.metadata);return this.#e.q(({metadata:h,blocks:u})=>{h.put(d);for(const f of r.changedPages)u.delete([r.path,-f,d.version-1]);r.changedPages.clear()},"rw",r.txOptions),r.needsMetadataSync=!1,r.rollback=null,o}}catch(r){return this.lastError=r,O}return super.jFileControl(e,t,s)}jDeviceCharacteristics(e){return 0|se|re}jGetLastError(e){if(this.lastError){console.error(this.lastError);const t=e.subarray(0,e.byteLength-1),{written:s}=new TextEncoder().encodeInto(this.lastError.message,t);e[s]=0}return o}}function P(g,e){const t=g.getUint32(e,!0);if(t){const s=new Uint8Array(g.buffer,t);return new TextDecoder().decode(s.subarray(0,s.indexOf(0)))}return null}class F{#t;#e=null;#n=Promise.resolve();#r=null;#a=new WeakSet;log=null;static async create(e){const t=await new Promise((s,r)=>{const n=indexedDB.open(e,6);n.onupgradeneeded=async i=>{const a=n.result;switch(i.oldVersion&&console.log(`Upgrading IndexedDB from version ${i.oldVersion}`),i.oldVersion){case 0:a.createObjectStore("blocks",{keyPath:["path","offset","version"]}).createIndex("version",["path","version"]);case 5:const l=n.transaction;l.objectStore("blocks").deleteIndex("version");const d=a.createObjectStore("metadata",{keyPath:"name"});await new Promise((h,u)=>{let f={};const p=l.objectStore("blocks").openCursor();p.onsuccess=()=>{const m=p.result;if(m){const E=m.value;typeof E.offset!="number"||E.path===f.path&&E.offset===f.offset?m.delete():E.offset===0&&(d.put({name:E.path,fileSize:E.fileSize,version:E.version}),delete E.fileSize,m.update(E)),f=E,m.continue()}else h()},p.onerror=()=>u(p.error)});break}},n.onsuccess=()=>s(n.result),n.onerror=()=>r(n.error)});return new F(t)}constructor(e){this.#t=e}close(){this.#t.close()}q(e,t="ro",s={}){const r=t==="ro"?"readonly":"readwrite",n=Object.assign({durability:"default"},s);return this.#e=(this.#e||Promise.resolve()).then(()=>this.#i(e,r,n)),this.#e}async#i(e,t,s){let r;this.#r&&this.#a.has(this.#r.transaction)&&this.#r.transaction.mode>=t&&this.#r.transaction.durability===s.durability&&(r=this.#r.transaction,this.#r.readyState==="pending"&&await new Promise(n=>{this.#r.addEventListener("success",n,{once:!0}),this.#r.addEventListener("error",n,{once:!0})}));for(let n=0;n<2;++n){r||(await this.#n,r=this.#t.transaction(this.#t.objectStoreNames,t,s),this.log?.("IDBTransaction open",t),this.#a.add(r),this.#n=new Promise((a,l)=>{r.addEventListener("complete",()=>{this.log?.("IDBTransaction complete"),this.#a.delete(r),a()}),r.addEventListener("abort",()=>{this.#a.delete(r),l(new Error("transaction aborted"))})}));const i=[...r.objectStoreNames].map(a=>[a,this.proxyStoreOrIndex(r.objectStore(a))]);try{return await e(Object.fromEntries(i))}catch(a){if(!n&&a.name==="TransactionInactiveError"){this.log?.("TransactionInactiveError, retrying"),r=null;continue}throw a}}}proxyStoreOrIndex(e){return new Proxy(e,{get:(t,s,r)=>{const n=Reflect.get(t,s,r);return typeof n=="function"?(...i)=>{const a=Reflect.apply(n,t,i);return a instanceof IDBRequest&&!s.endsWith("Cursor")?(this.#r=a,a.addEventListener("error",()=>{console.error(a.error),a.transaction.abort()},{once:!0}),he(a)):a}:n}})}async sync(e){this.#e&&(await this.#e,e&&await this.#n,this.reset())}reset(){this.#e=null,this.#n=Promise.resolve(),this.#r=null}}function he(g){return new Promise((e,t)=>{g.onsuccess=()=>e(g.result),g.onerror=()=>t(g.error)})}export{N as IDBBatchAtomicVFS,F as IDBContext};
//# sourceMappingURL=IDBBatchAtomicVFS-DBAaJ-a6.js.map
