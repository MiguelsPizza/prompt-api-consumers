{"version":3,"file":"IDBBatchAtomicVFS-DRhPG5Q9.js","sources":["../../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.0.0/node_modules/@journeyapps/wa-sqlite/src/VFS.js","../../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.0.0/node_modules/@journeyapps/wa-sqlite/src/FacadeVFS.js","../../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.0.0/node_modules/@journeyapps/wa-sqlite/src/WebLocksMixin.js","../../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.0.0/node_modules/@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js"],"sourcesContent":["// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\nconst DEFAULT_SECTOR_SIZE = 512;\n\n// Base class for a VFS.\nexport class Base {\n  name;\n  mxPathname = 64;\n  _module;\n\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    this.name = name;\n    this._module = module;\n  }\n\n  /**\n   * @returns {void|Promise<void>} \n   */\n  close() {\n  }\n\n  /**\n   * @returns {boolean|Promise<boolean>}\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Overload in subclasses to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    return false;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    return DEFAULT_SECTOR_SIZE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    return 0;\n  }\n}\n\nexport const FILE_TYPE_MASK = [\n  VFS.SQLITE_OPEN_MAIN_DB,\n  VFS.SQLITE_OPEN_MAIN_JOURNAL,\n  VFS.SQLITE_OPEN_TEMP_DB,\n  VFS.SQLITE_OPEN_TEMP_JOURNAL,\n  VFS.SQLITE_OPEN_TRANSIENT_DB,\n  VFS.SQLITE_OPEN_SUBJOURNAL,\n  VFS.SQLITE_OPEN_SUPER_JOURNAL,\n  VFS.SQLITE_OPEN_WAL\n].reduce((mask, element) => mask | element);","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './VFS.js';\n\nconst AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\n// Convenience base class for a JavaScript VFS.\n// The raw xOpen, xRead, etc. function signatures receive only C primitives\n// which aren't easy to work with. This class provides corresponding calls\n// like jOpen, jRead, etc., which receive JavaScript-friendlier arguments\n// such as string, Uint8Array, and DataView.\nexport class FacadeVFS extends VFS.Base {\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    super(name, module);\n  }\n\n  /**\n   * Override to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    // The input argument is a string like \"xOpen\", so convert to \"jOpen\".\n    // Then check if the method exists and is async.\n    const jMethodName = `j${methodName.slice(1)}`;\n    return this[jMethodName] instanceof AsyncFunction;\n  }\n  \n  /**\n   * Return the filename for a file id for use by mixins.\n   * @param {number} pFile \n   * @returns {string}\n   */\n  getFilename(pFile) {\n    throw new Error('unimplemented');\n  }\n\n  /**\n   * @param {string?} filename \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  jOpen(filename, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  jDelete(filename, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jAccess(filename, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {Uint8Array} zOut \n   * @returns {number|Promise<number>}\n   */\n  jFullPathname(filename, zOut) {\n    // Copy the filename to the output buffer.\n    const { read, written } = new TextEncoder().encodeInto(filename, zOut);\n    if (read < filename.length) return VFS.SQLITE_IOERR;\n    if (written >= zOut.length) return VFS.SQLITE_IOERR;\n    zOut[written] = 0;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  jClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jRead(pFile, pData, iOffset) {\n    pData.fill(0);\n    return VFS.SQLITE_IOERR_SHORT_READ;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jWrite(pFile, pData, iOffset) {\n    return VFS.SQLITE_IOERR_WRITE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} size \n   * @returns {number|Promise<number>}\n   */\n  jTruncate(pFile, size) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  jSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pSize\n   * @returns {number|Promise<number>}\n   */\n  jFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jCheckReservedLock(pFile, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jSectorSize(pFile) {\n    return super.xSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    const filename = this.#decodeFilename(zName, flags);\n    const pOutFlagsView = this.#makeTypedDataView('Int32', pOutFlags);\n    this['log']?.('jOpen', filename, pFile, '0x' + flags.toString(16));\n    return this.jOpen(filename, pFile, flags, pOutFlagsView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    const filename = this._module.UTF8ToString(zName);\n    this['log']?.('jDelete', filename, syncDir);\n    return this.jDelete(filename, syncDir);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jAccess', filename, flags);\n    return this.jAccess(filename, flags, pResOutView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);\n    this['log']?.('jFullPathname', filename, nOut);\n    return this.jFullPathname(filename, zOutArray);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);\n    this['log']?.('jGetLastError', nBuf);\n    return this.jGetLastError(zBufArray);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    this['log']?.('jClose', pFile);\n    return this.jClose(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jRead', pFile, iAmt, iOffset);\n    return this.jRead(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jWrite', pFile, pDataArray, iOffset);\n    return this.jWrite(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    const size = delegalize(sizeLo, sizeHi);\n    this['log']?.('jTruncate', pFile, size);\n    return this.jTruncate(pFile, size);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    this['log']?.('jSync', pFile, flags);\n    return this.jSync(pFile, flags);\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    const pSizeView = this.#makeTypedDataView('BigInt64', pSize);\n    this['log']?.('jFileSize', pFile);\n    return this.jFileSize(pFile, pSizeView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    this['log']?.('jLock', pFile, lockType);\n    return this.jLock(pFile, lockType);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    this['log']?.('jUnlock', pFile, lockType);\n    return this.jUnlock(pFile, lockType);\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jCheckReservedLock', pFile);\n    return this.jCheckReservedLock(pFile, pResOutView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    const pArgView = new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + pArg);\n    this['log']?.('jFileControl', pFile, op, pArgView);\n    return this.jFileControl(pFile, op, pArgView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    this['log']?.('jSectorSize', pFile);\n    return this.jSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    this['log']?.('jDeviceCharacteristics', pFile);\n    return this.jDeviceCharacteristics(pFile);\n  }\n\n  /**\n   * Wrapped DataView for pointer arguments.\n   * Pointers to a single value are passed using DataView. A Proxy\n   * wrapper prevents use of incorrect type or endianness.\n   * @param {'Int32'|'BigInt64'} type \n   * @param {number} byteOffset \n   * @returns {DataView}\n   */\n  #makeTypedDataView(type, byteOffset) {\n    const byteLength = type === 'Int32' ? 4 : 8;\n    const getter = `get${type}`;\n    const setter = `set${type}`;\n    const makeDataView = () => new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + byteOffset,\n      byteLength);\n    let dataView = makeDataView();\n    return new Proxy(dataView, {\n      get(_, prop) {\n        if (dataView.buffer.byteLength === 0) {\n          // WebAssembly memory resize detached the buffer.\n          dataView = makeDataView();\n        }\n        if (prop === getter) {\n          return function(byteOffset, littleEndian) {\n            if (!littleEndian) throw new Error('must be little endian');\n            return dataView[prop](byteOffset, littleEndian);\n          }\n        }\n        if (prop === setter) {\n          return function(byteOffset, value, littleEndian) {\n            if (!littleEndian) throw new Error('must be little endian');\n            return dataView[prop](byteOffset, value, littleEndian);\n          }\n        }\n        if (typeof prop === 'string' && (prop.match(/^(get)|(set)/))) {\n          throw new Error('invalid type');\n        }\n        const result = dataView[prop];\n        return typeof result === 'function' ? result.bind(dataView) : result;\n      }\n    });\n  }\n\n  /**\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   */\n  #makeDataArray(byteOffset, byteLength) {\n    let target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);\n    return new Proxy(target, {\n      get: (_, prop, receiver) => {\n        if (target.buffer.byteLength === 0) {\n          // WebAssembly memory resize detached the buffer.\n          target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);\n        }\n        const result = target[prop];\n        return typeof result === 'function' ? result.bind(target) : result;\n      }\n    });\n  }\n\n  #decodeFilename(zName, flags) {\n    if (flags & VFS.SQLITE_OPEN_URI) {\n      // The first null-terminated string is the URI path. Subsequent\n      // strings are query parameter keys and values.\n      // https://www.sqlite.org/c3ref/open.html#urifilenamesinsqlite3open\n      let pName = zName;\n      let state = 1;\n      const charCodes = [];\n      while (state) {\n        const charCode = this._module.HEAPU8[pName++];\n        if (charCode) {\n          charCodes.push(charCode);\n        } else {\n          if (!this._module.HEAPU8[pName]) state = null;\n          switch (state) {\n            case 1: // path\n              charCodes.push('?'.charCodeAt(0));\n              state = 2;\n              break;\n            case 2: // key\n              charCodes.push('='.charCodeAt(0));\n              state = 3;\n              break;\n            case 3: // value\n              charCodes.push('&'.charCodeAt(0));\n              state = 2;\n              break;\n          }\n        }\n      }\n      return  new TextDecoder().decode(new Uint8Array(charCodes));\n    }\n    return zName ? this._module.UTF8ToString(zName) : null;\n  }\n}\n\n// Emscripten \"legalizes\" 64-bit integer arguments by passing them as\n// two 32-bit signed integers.\nfunction delegalize(lo32, hi32) {\n  return (hi32 * 0x100000000) + lo32 + (lo32 < 0 ? 2**32 : 0);\n}\n","import * as VFS from './VFS.js';\n\n// Options for navigator.locks.request().\n/** @type {LockOptions} */ const SHARED = { mode: 'shared' };\n/** @type {LockOptions} */ const POLL_SHARED = { ifAvailable: true, mode: 'shared' };\n/** @type {LockOptions} */ const POLL_EXCLUSIVE = { ifAvailable: true, mode: 'exclusive' };\n\nconst POLICIES = ['exclusive', 'shared', 'shared+hint'];\n\n/**\n * @typedef LockState\n * @property {string} baseName\n * @property {number} type\n * @property {boolean} writeHint\n * \n * These properties are functions that release a specific lock.\n * @property {(() => void)?} [gate]\n * @property {(() => void)?} [access]\n * @property {(() => void)?} [reserved]\n * @property {(() => void)?} [hint]\n */\n\n/**\n * Mix-in for FacadeVFS that implements the SQLite VFS locking protocol.\n * @param {*} superclass FacadeVFS (or subclass)\n * @returns \n */\nexport const WebLocksMixin = superclass => class extends superclass {\n  #options = {\n    lockPolicy: 'exclusive',\n    lockTimeout: Infinity\n  };\n\n  /** @type {Map<number, LockState>} */ #mapIdToState = new Map();\n\n  constructor(name, module, options) {\n    super(name, module, options);\n    Object.assign(this.#options, options);\n    if (POLICIES.indexOf(this.#options.lockPolicy) === -1) {\n      throw new Error(`WebLocksMixin: invalid lock mode: ${options.lockPolicy}`);\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jLock(fileId, lockType) {\n    try {\n      // Create state on first lock.\n      if (!this.#mapIdToState.has(fileId)) {\n        const name = this.getFilename(fileId);\n        const state = {\n          baseName: name,\n          type: VFS.SQLITE_LOCK_NONE,\n          writeHint: false\n        };\n        this.#mapIdToState.set(fileId, state);\n      }\n\n      const lockState = this.#mapIdToState.get(fileId);\n      if (lockType <= lockState.type) return VFS.SQLITE_OK;\n  \n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return await this.#lockExclusive(lockState, lockType);\n        case 'shared':\n        case 'shared+hint':\n          return await this.#lockShared(lockState, lockType);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: lock error', e);\n      return VFS.SQLITE_IOERR_LOCK;\n    }\n  }\n  \n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jUnlock(fileId, lockType) {\n    try {\n      const lockState = this.#mapIdToState.get(fileId);\n      if (lockType >= lockState.type) return VFS.SQLITE_OK;\n  \n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return await this.#unlockExclusive(lockState, lockType);\n        case 'shared':\n        case 'shared+hint':\n            return await this.#unlockShared(lockState, lockType);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: unlock error', e);\n      return VFS.SQLITE_IOERR_UNLOCK;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async jCheckReservedLock(fileId, pResOut) {\n    try {\n      const lockState = this.#mapIdToState.get(fileId);\n      switch (this.#options.lockPolicy) {\n        case 'exclusive':\n          return this.#checkReservedExclusive(lockState, pResOut);\n        case 'shared':\n        case 'shared+hint':\n          return await this.#checkReservedShared(lockState, pResOut);\n      }\n    } catch (e) {\n      console.error('WebLocksMixin: check reserved lock error', e);\n      return VFS.SQLITE_IOERR_CHECKRESERVEDLOCK;\n    }\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(pFile, op, pArg) {\n    const lockState = this.#mapIdToState.get(pFile) ??\n      (() => {\n        // Call jLock() to create the lock state.\n        this.jLock(pFile, VFS.SQLITE_LOCK_NONE);\n        return this.#mapIdToState.get(pFile);\n      })();\n    if (op === WebLocksMixin.WRITE_HINT_OP_CODE &&\n        this.#options.lockPolicy === 'shared+hint'){\n      lockState.writeHint = true;\n    }\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #lockExclusive(lockState, lockType) {\n    if (!lockState.access) {\n      if (!await this.#acquire(lockState, 'access')) {\n        return VFS.SQLITE_BUSY;\n      }\n      console.assert(!!lockState.access);\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns {number}\n   */\n  #unlockExclusive(lockState, lockType) {\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      lockState.access?.();\n      console.assert(!lockState.access);\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  #checkReservedExclusive(lockState, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #lockShared(lockState, lockType) {\n    switch (lockState.type) {\n      case VFS.SQLITE_LOCK_NONE:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_SHARED:\n            if (lockState.writeHint) {\n              // xFileControl() has hinted that this transaction will\n              // write. Acquire the hint lock, which is required to reach\n              // the RESERVED state.\n              if (!await this.#acquire(lockState, 'hint')) {\n                // Timeout before lock acquired.\n                return VFS.SQLITE_BUSY;\n              }\n            }\n\n            // Must have the gate lock to request the access lock.\n            if (!await this.#acquire(lockState, 'gate', SHARED)) {\n                // Timeout before lock acquired.\n                lockState.hint?.();\n              return VFS.SQLITE_BUSY;\n            }\n            await this.#acquire(lockState, 'access', SHARED);\n            lockState.gate();\n            console.assert(!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n      case VFS.SQLITE_LOCK_SHARED:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_RESERVED:\n            if (this.#options.lockPolicy === 'shared+hint') {\n              // Ideally we should already have the hint lock, but if not\n              // poll for it here.\n              if (!lockState.hint &&\n                !await this.#acquire(lockState, 'hint', POLL_EXCLUSIVE)) {\n                // Another connection has the hint lock so this is a\n                // deadlock. This connection must retry.\n                return VFS.SQLITE_BUSY;\n              }\n            }\n\n            // Poll for the reserved lock. This should always succeed\n            // if all clients use the 'shared+hint' policy.\n            if (!await this.#acquire(lockState, 'reserved', POLL_EXCLUSIVE)) {\n              // This is a deadlock. The connection holding the reserved\n              // lock blocks us, and it can't acquire an exclusive access\n              // lock because we hold a shared access lock. This connection\n              // must retry.\n              lockState.hint?.();\n              return VFS.SQLITE_BUSY;\n            }\n            lockState.access();\n            console.assert(!lockState.gate);\n            console.assert(!lockState.access);\n            console.assert(!!lockState.reserved);\n            break;\n\n          case VFS.SQLITE_LOCK_EXCLUSIVE:\n            // Jumping directly from SHARED to EXCLUSIVE without passing\n            // through RESERVED is only done with a hot journal.\n            if (!await this.#acquire(lockState, 'gate')) {\n              // Timeout before lock acquired.\n              return VFS.SQLITE_BUSY;\n            }\n            lockState.access();\n            if (!await this.#acquire(lockState, 'access')) {\n              // Timeout before lock acquired.\n              lockState.gate();\n              return VFS.SQLITE_BUSY;\n            }\n            console.assert(!!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n      case VFS.SQLITE_LOCK_RESERVED:\n        switch (lockType) {\n          case VFS.SQLITE_LOCK_EXCLUSIVE:\n            // Prevent other connections from entering the SHARED state.\n            if (!await this.#acquire(lockState, 'gate')) {\n              // Timeout before lock acquired.\n              return VFS.SQLITE_BUSY;\n            }\n\n            // Block until all other connections exit the SHARED state.\n            if (!await this.#acquire(lockState, 'access')) {\n              // Timeout before lock acquired.\n              lockState.gate();\n              return VFS.SQLITE_BUSY;\n            }\n            console.assert(!!lockState.gate);\n            console.assert(!!lockState.access);\n            console.assert(!!lockState.reserved);\n            break;\n\n          default:\n            throw new Error('unsupported lock transition');\n        }\n        break;\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {number} lockType \n   * @returns \n   */\n  async #unlockShared(lockState, lockType) {\n    // lockType can only be SQLITE_LOCK_SHARED or SQLITE_LOCK_NONE.\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      lockState.access?.();\n      lockState.gate?.();\n      lockState.reserved?.();\n      lockState.hint?.();\n      lockState.writeHint = false;\n      console.assert(!lockState.access);\n      console.assert(!lockState.gate);\n      console.assert(!lockState.reserved);\n      console.assert(!lockState.hint);\n    } else { // lockType === VFS.SQLITE_LOCK_SHARED\n      switch (lockState.type) {\n        case VFS.SQLITE_LOCK_EXCLUSIVE:\n          // Release our exclusive access lock and reacquire it with a\n          // shared lock. This should always succeed because we hold\n          // the gate lock.\n          lockState.access();\n          await this.#acquire(lockState, 'access', SHARED);\n\n          // Release our gate and reserved locks. We might not have a\n          // reserved lock if we were handling a hot journal.\n          lockState.gate();\n          lockState.reserved?.();\n          lockState.hint?.();\n          console.assert(!!lockState.access);\n          console.assert(!lockState.gate);\n          console.assert(!lockState.reserved);\n          break;\n\n        case VFS.SQLITE_LOCK_RESERVED:\n          // This transition is rare, probably only on an I/O error\n          // while writing to a journal file.\n          await this.#acquire(lockState, 'access', SHARED);\n          lockState.reserved();\n          lockState.hint?.();\n          console.assert(!!lockState.access);\n          console.assert(!lockState.gate);\n          console.assert(!lockState.reserved);\n          break;\n      }\n    }\n    lockState.type = lockType;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async #checkReservedShared(lockState, pResOut) {\n    if (await this.#acquire(lockState, 'reserved', POLL_SHARED)) {\n      // We were able to get the lock so it was not reserved.\n      lockState.reserved();\n      pResOut.setInt32(0, 0, true);\n    } else {\n      pResOut.setInt32(0, 1, true);\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {LockState} lockState \n   * @param {'gate'|'access'|'reserved'|'hint'} name\n   * @param {LockOptions} options \n   * @returns {Promise<boolean>}\n   */\n  #acquire(lockState, name, options = {}) {\n    console.assert(!lockState[name]);\n    return new Promise(resolve => {\n      if (!options.ifAvailable && this.#options.lockTimeout < Infinity) {\n        // Add a timeout to the lock request.\n        const controller = new AbortController();\n        options = Object.assign({}, options, { signal: controller.signal });\n        setTimeout(() => {\n          controller.abort();\n          resolve?.(false);\n        }, this.#options.lockTimeout);\n      }\n\n      const lockName = `lock##${lockState.baseName}##${name}`;\n      navigator.locks.request(lockName, options, lock => {\n        if (lock) {\n          return new Promise(release => {\n            lockState[name] = () => {\n              release();\n              lockState[name] = null;\n            };\n            resolve(true);\n            resolve = null;\n          });\n        } else {\n          lockState[name] = null;\n          resolve(false);\n          resolve = null;\n        }\n      }).catch(e => {\n        if (e.name !== 'AbortError') throw e;\n      });\n    });\n  }\n}\n\nWebLocksMixin.WRITE_HINT_OP_CODE = -9999;","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport { FacadeVFS } from '../FacadeVFS.js';\nimport * as VFS from '../VFS.js';\nimport { WebLocksMixin } from '../WebLocksMixin.js';\n\n/**\n * @typedef Metadata\n * @property {string} name\n * @property {number} fileSize\n * @property {number} version\n * @property {number} [pendingVersion]\n */\n\nclass File {\n  /** @type {string} */ path;\n  /** @type {number} */ flags;\n\n  /** @type {Metadata} */ metadata;\n  /** @type {number} */ fileSize = 0;\n\n  /** @type {boolean} */ needsMetadataSync = false;\n  /** @type {Metadata} */ rollback = null;\n  /** @type {Set<number>} */ changedPages = new Set();\n\n  /** @type {string} */ synchronous = 'full';\n  /** @type {IDBTransactionOptions} */ txOptions = { durability: 'strict' };\n\n  constructor(path, flags, metadata) {\n    this.path = path;\n    this.flags = flags;\n    this.metadata = metadata;\n  }\n}\n\nexport class IDBBatchAtomicVFS extends WebLocksMixin(FacadeVFS) {\n  /** @type {Map<number, File>} */ mapIdToFile = new Map();\n  lastError = null;\n\n  log = null; // console.log\n\n  /** @type {Promise} */ #isReady;\n  /** @type {IDBContext} */ #idb;\n\n  static async create(name, module, options) {\n    const vfs = new IDBBatchAtomicVFS(name, module, options);\n    await vfs.isReady();\n    return vfs;\n  }\n\n  constructor(name, module, options = {}) {\n    super(name, module, options);\n    this.#isReady = this.#initialize(options.idbName ?? name);\n  }\n\n  async #initialize(name) {\n    this.#idb = await IDBContext.create(name);\n  }\n\n  close() {\n    this.#idb.close();\n  }\n  \n  async isReady() {\n    await super.isReady();\n    await this.#isReady;\n  }\n\n  getFilename(fileId) {\n    const pathname = this.mapIdToFile.get(fileId).path;\n    return `IDB(${this.name}):${pathname}`\n  }\n  \n  /**\n   * @param {string?} zName \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {Promise<number>}\n   */\n  async jOpen(zName, fileId, flags, pOutFlags) {\n    try {\n      const url = new URL(zName || Math.random().toString(36).slice(2), 'file://');\n      const path = url.pathname;\n\n      let meta = await this.#idb.q(({ metadata }) => metadata.get(path));\n      if (!meta && (flags & VFS.SQLITE_OPEN_CREATE)) {\n        meta = {\n          name: path,\n          fileSize: 0,\n          version: 0\n        };\n        await this.#idb.q(({ metadata }) => metadata.put(meta), 'rw');\n      }\n      \n      if (!meta) {\n        throw new Error(`File ${path} not found`);\n      }\n\n      const file = new File(path, flags, meta);\n      this.mapIdToFile.set(fileId, file);\n      pOutFlags.setInt32(0, flags, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_CANTOPEN;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} syncDir \n   * @returns {Promise<number>}\n   */\n  async jDelete(zName, syncDir) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n\n      this.#idb.q(({ metadata, blocks }) => {\n        const range = IDBKeyRange.bound([path, -Infinity], [path, Infinity]);\n        blocks.delete(range);\n        metadata.delete(path);\n      }, 'rw');\n\n      if (syncDir) {\n        await this.#idb.sync(false);\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_DELETE;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {Promise<number>}\n   */\n  async jAccess(zName, flags, pResOut) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n\n      const meta = await this.#idb.q(({ metadata }) => metadata.get(path));\n      pResOut.setInt32(0, meta ? 1 : 0, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_ACCESS;\n    } \n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {Promise<number>}\n   */\n  async jClose(fileId) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      this.mapIdToFile.delete(fileId);\n\n      if (file.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n        await this.#idb.q(({ metadata, blocks }) => {\n          metadata.delete(file.path);\n          blocks.delete(IDBKeyRange.bound([file.path, 0], [file.path, Infinity]));\n        }, 'rw');        \n      }\n\n      if (file.needsMetadataSync) {\n        this.#idb.q(({ metadata }) => metadata.put(file.metadata), 'rw');\n      }\n      await this.#idb.sync(file.synchronous === 'full');\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_CLOSE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {Promise<number>}\n   */\n  async jRead(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n\n      let pDataOffset = 0;\n      while (pDataOffset < pData.byteLength) {\n        // Fetch the IndexedDB block for this file location.\n        const fileOffset = iOffset + pDataOffset;\n        const block = await this.#idb.q(({ blocks }) => {\n          const range = IDBKeyRange.bound([file.path, -fileOffset], [file.path, Infinity]);\n          return blocks.get(range);\n        });       \n        \n        if (!block || block.data.byteLength - block.offset <= fileOffset) {\n          pData.fill(0, pDataOffset);\n          return VFS.SQLITE_IOERR_SHORT_READ;\n        }\n\n        // Copy block data.\n        const dst = pData.subarray(pDataOffset);\n        const srcOffset = fileOffset + block.offset;\n        const nBytesToCopy = Math.min(\n          Math.max(block.data.byteLength - srcOffset, 0),\n          dst.byteLength);\n        dst.set(block.data.subarray(srcOffset, srcOffset + nBytesToCopy));\n        pDataOffset += nBytesToCopy;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_READ;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jWrite(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        if (!file.rollback) {\n          // Begin a new write transaction.\n          // Add pendingVersion to the metadata in IndexedDB. If we crash\n          // during the transaction, this lets subsequent connections\n          // know to remove blocks from the failed transaction.\n          const pending = Object.assign(\n            { pendingVersion: file.metadata.version - 1 },\n            file.metadata);\n          this.#idb.q(({ metadata }) => metadata.put(pending), 'rw', file.txOptions);\n\n          file.rollback = Object.assign({}, file.metadata);\n          file.metadata.version--;\n        }\n      }\n\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        file.changedPages.add(iOffset);\n      }\n\n      const data = pData.slice();\n      const version = file.metadata.version;\n      const isOverwrite = iOffset < file.metadata.fileSize;\n      if (!isOverwrite ||\n          file.flags & VFS.SQLITE_OPEN_MAIN_DB ||\n          file.flags & VFS.SQLITE_OPEN_TEMP_DB) {\n        const block = {\n          path: file.path,\n          offset: -iOffset,\n          version: version,\n          data: pData.slice()\n        };\n        this.#idb.q(({ blocks }) => {\n          blocks.put(block);\n          file.changedPages.add(iOffset);\n        }, 'rw', file.txOptions);\n      } else {\n        this.#idb.q(async ({ blocks }) => {\n          // Read the existing block.\n          const range = IDBKeyRange.bound(\n            [file.path, -iOffset],\n            [file.path, Infinity]);\n          const block = await blocks.get(range);\n\n          // Modify the block data.\n          // @ts-ignore\n          block.data.subarray(iOffset + block.offset).set(data);\n\n          // Write back.\n          blocks.put(block);\n        }, 'rw', file.txOptions);\n\n      }\n\n      if (file.metadata.fileSize < iOffset + pData.length) {\n        file.metadata.fileSize = iOffset + pData.length;\n        file.needsMetadataSync = true;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_WRITE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  jTruncate(fileId, iSize) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (iSize < file.metadata.fileSize) {\n        this.#idb.q(({ blocks }) => {\n          const range = IDBKeyRange.bound(\n            [file.path, -Infinity],\n            [file.path, -iSize, Infinity]);\n          blocks.delete(range);\n        }, 'rw', file.txOptions);\n        file.metadata.fileSize = iSize;\n        file.needsMetadataSync = true;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_TRUNCATE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {Promise<number>}\n   */\n  async jSync(fileId, flags) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      if (file.needsMetadataSync) {\n        this.#idb.q(({ metadata }) => metadata.put(file.metadata), 'rw', file.txOptions);\n        file.needsMetadataSync = false;\n      }\n\n      if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        // Sync is only needed here for durability. Visibility for other\n        // connections is ensured in jUnlock().\n        if (file.synchronous === 'full') {\n          await this.#idb.sync(true);\n        }\n      } else {\n        await this.#idb.sync(file.synchronous === 'full');\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSYNC;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  jFileSize(fileId, pSize64) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      pSize64.setBigInt64(0, BigInt(file.metadata.fileSize), true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSTAT;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jLock(fileId, lockType) {\n    // Call the actual lock implementation.\n    const file = this.mapIdToFile.get(fileId);\n    const result = await super.jLock(fileId, lockType);\n\n    if (lockType === VFS.SQLITE_LOCK_SHARED) {\n      // Update metadata.\n      file.metadata = await this.#idb.q(async ({ metadata, blocks }) => {\n        // @ts-ignore\n        /** @type {Metadata} */ const m = await metadata.get(file.path);\n        if (m.pendingVersion) {\n          console.warn(`removing failed transaction ${m.pendingVersion}`);\n          await new Promise((resolve, reject) => {\n            const range = IDBKeyRange.bound([m.name, -Infinity], [m.name, Infinity]);\n            const request = blocks.openCursor(range);\n            request.onsuccess = () => {\n              const cursor = request.result;\n              if (cursor) {\n                const block = cursor.value;\n                if (block.version < m.version) {\n                  cursor.delete();\n                }\n                cursor.continue();\n              } else {\n                resolve();\n              }\n            };\n            request.onerror = () => reject(request.error);\n          })\n\n          delete m.pendingVersion;\n          metadata.put(m);\n        }\n        return m;\n      }, 'rw', file.txOptions);\n    }\n    return result;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {Promise<number>}\n   */\n  async jUnlock(fileId, lockType) {\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      const file = this.mapIdToFile.get(fileId);\n      await this.#idb.sync(file.synchronous === 'full');\n    }\n\n    // Call the actual unlock implementation.\n    return super.jUnlock(fileId, lockType);\n  }\n\n  /**\n   * @param {number} fileId\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(fileId, op, pArg) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      switch (op) {\n        case VFS.SQLITE_FCNTL_PRAGMA:\n          const key = extractString(pArg, 4);\n          const value = extractString(pArg, 8);\n          this.log?.('xFileControl', file.path, 'PRAGMA', key, value);\n          const setPragmaResponse = response => {\n            const encoded = new TextEncoder().encode(response);\n            const out = this._module._sqlite3_malloc(encoded.byteLength);\n            const outArray = this._module.HEAPU8.subarray(out, out + encoded.byteLength);\n            outArray.set(encoded);\n            pArg.setUint32(0, out, true);\n            return VFS.SQLITE_ERROR;\n          };\n          switch (key.toLowerCase()) {\n            case 'page_size':\n              if (file.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n                // Don't allow changing the page size.\n                if (value && file.metadata.fileSize) {\n                  return VFS.SQLITE_ERROR;\n                }\n              }\n              break;\n            case 'synchronous':\n              if (value) {\n                switch (value.toLowerCase()) {\n                  case '0':\n                  case 'off':\n                    file.synchronous = 'off';\n                    file.txOptions = { durability: 'relaxed' };\n                    break;\n                  case '1':\n                  case 'normal':\n                    file.synchronous = 'normal';\n                    file.txOptions = { durability: 'relaxed' };\n                    break;\n                  case '2':\n                  case '3':\n                  case 'full':\n                  case 'extra':\n                    file.synchronous = 'full';\n                    file.txOptions = { durability: 'strict' };\n                    break;\n                }\n              }\n              break;\n            case 'write_hint':\n              return super.jFileControl(fileId, WebLocksMixin.WRITE_HINT_OP_CODE, null);\n            }\n          break;\n        case VFS.SQLITE_FCNTL_SYNC:\n          this.log?.('xFileControl', file.path, 'SYNC');\n          const commitMetadata = Object.assign({}, file.metadata);\n          const prevFileSize = file.rollback.fileSize\n          this.#idb.q(({ metadata, blocks }) => {\n            metadata.put(commitMetadata);\n\n            // Remove old page versions.\n            for (const offset of file.changedPages) {\n              if (offset < prevFileSize) {\n                const range = IDBKeyRange.bound(\n                  [file.path, -offset, commitMetadata.version],\n                  [file.path, -offset, Infinity],\n                  true);\n                blocks.delete(range);\n              }\n            }\n            file.changedPages.clear();\n          }, 'rw', file.txOptions);\n          file.needsMetadataSync = false;\n          file.rollback = null;\n          break;\n        case VFS.SQLITE_FCNTL_BEGIN_ATOMIC_WRITE:\n          // Every write transaction is atomic, so this is a no-op.\n          this.log?.('xFileControl', file.path, 'BEGIN_ATOMIC_WRITE');\n          return VFS.SQLITE_OK;\n        case VFS.SQLITE_FCNTL_COMMIT_ATOMIC_WRITE:\n          // Every write transaction is atomic, so this is a no-op.\n          this.log?.('xFileControl', file.path, 'COMMIT_ATOMIC_WRITE');\n          return VFS.SQLITE_OK;\n        case VFS.SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE:\n          this.log?.('xFileControl', file.path, 'ROLLBACK_ATOMIC_WRITE');\n          file.metadata = file.rollback;\n          const rollbackMetadata = Object.assign({}, file.metadata);\n          this.#idb.q(({ metadata, blocks }) => {\n            metadata.put(rollbackMetadata);\n\n            // Remove pages.\n            for (const offset of file.changedPages) {\n              blocks.delete([file.path, -offset, rollbackMetadata.version - 1]);\n            }\n            file.changedPages.clear();\n          }, 'rw', file.txOptions);\n          file.needsMetadataSync = false;\n          file.rollback = null;\n          return VFS.SQLITE_OK;\n      }\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR;\n    }\n    return super.jFileControl(fileId, op, pArg);\n  }\n  \n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0\n    | VFS.SQLITE_IOCAP_BATCH_ATOMIC\n    | VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    if (this.lastError) {\n      console.error(this.lastError);\n      const outputArray = zBuf.subarray(0, zBuf.byteLength - 1);\n      const { written } = new TextEncoder().encodeInto(this.lastError.message, outputArray);\n      zBuf[written] = 0;\n    }\n    return VFS.SQLITE_OK\n  }\n}\n\nfunction extractString(dataView, offset) {\n  const p = dataView.getUint32(offset, true);\n  if (p) {\n    const chars = new Uint8Array(dataView.buffer, p);\n    return new TextDecoder().decode(chars.subarray(0, chars.indexOf(0)));\n  }\n  return null;\n}\n\nexport class IDBContext {\n  /** @type {IDBDatabase} */ #database;\n\n  /** @type {Promise} */ #chain = null;\n  /** @type {Promise<any>} */ #txComplete = Promise.resolve();\n  /** @type {IDBRequest?} */ #request = null;\n  /** @type {WeakSet<IDBTransaction>} */ #txPending = new WeakSet();\n  \n  log = null;\n\n  static async create(name) {\n    const database = await new Promise((resolve, reject) => {\n      const request = indexedDB.open(name, 6);\n      request.onupgradeneeded = async event => {\n        const db = request.result;\n        if (event.oldVersion) {\n          console.log(`Upgrading IndexedDB from version ${event.oldVersion}`);\n        }\n        switch (event.oldVersion) {\n          case 0:\n            // Start with the original schema.\n            db.createObjectStore('blocks', { keyPath: ['path', 'offset', 'version']})\n              .createIndex('version', ['path', 'version']);\n            // fall through intentionally\n          case 5:\n            const tx = request.transaction;\n            const blocks = tx.objectStore('blocks');\n            blocks.deleteIndex('version');\n            const metadata = db.createObjectStore('metadata', { keyPath: 'name' });\n\n            await new Promise((resolve, reject) => {\n              // Iterate over all the blocks.\n              let lastBlock = {};\n              const request = tx.objectStore('blocks').openCursor();\n              request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                  const block = cursor.value;\n                  if (typeof block.offset !== 'number' ||\n                      (block.path === lastBlock.path && block.offset === lastBlock.offset)) {\n                    // Remove superceded block (or the \"purge\" info).\n                    cursor.delete();\n                  } else if (block.offset === 0) {\n                    // Move metadata to its own store.\n                    metadata.put({\n                      name: block.path,\n                      fileSize: block.fileSize,\n                      version: block.version\n                    });\n\n                    delete block.fileSize;\n                    cursor.update(block);\n                  }\n                  lastBlock = block;\n                  cursor.continue();\n                } else {\n                  resolve();\n                }\n              };\n              request.onerror = () => reject(request.error);\n            });\n            break;\n        }\n      };\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n    return new IDBContext(database);\n  }\n\n  constructor(database) {\n    this.#database = database;\n  }\n\n  close() {\n    this.#database.close();\n  }\n\n  /**\n   * @param {(stores: Object.<string, IDBObjectStore>) => any} f \n   * @param {'ro'|'rw'} mode \n   * @returns {Promise<any>}\n   */\n  q(f, mode = 'ro', options = {}) {\n    /** @type {IDBTransactionMode} */\n    const txMode = mode === 'ro' ? 'readonly' : 'readwrite';\n    const txOptions = Object.assign({\n      /** @type {IDBTransactionDurability} */ durability: 'default'\n    }, options);\n\n    // Ensure that queries run sequentially. If any function rejects,\n    // or any request has an error, or the transaction does not commit,\n    // then no subsequent functions will run until sync() or reset().\n    this.#chain = (this.#chain || Promise.resolve())\n      .then(() => this.#q(f, txMode, txOptions));\n    return this.#chain;\n  }\n\n  /**\n   * @param {(stores: Object.<string, IDBObjectStore>) => any} f \n   * @param {IDBTransactionMode} mode \n   * @param {IDBTransactionOptions} options\n   * @returns {Promise<any>}\n   */\n  async #q(f, mode, options) {\n    /** @type {IDBTransaction} */ let tx;\n    if (this.#request &&\n        this.#txPending.has(this.#request.transaction) &&\n        this.#request.transaction.mode >= mode &&\n        this.#request.transaction.durability === options.durability) {\n      // The previous request transaction is compatible and has\n      // not yet completed.\n      tx = this.#request.transaction;\n\n      // If the previous request is pending, wait for it to complete.\n      // This ensures that the transaction will be active.\n      if (this.#request.readyState === 'pending') {\n        await new Promise(resolve => {\n          this.#request.addEventListener('success', resolve, { once: true });\n          this.#request.addEventListener('error', resolve, { once: true });\n        });\n      }\n    }\n\n    for (let i = 0; i < 2; ++i) {\n      if (!tx) {\n        // The current transaction is missing or doesn't match so\n        // replace it with a new one. wait for the previous\n        // transaction to complete so the lifetimes do not overlap.\n        await this.#txComplete;\n\n        // Create the new transaction.\n        // @ts-ignore\n        tx = this.#database.transaction(this.#database.objectStoreNames, mode, options);\n        this.log?.('IDBTransaction open', mode);\n        this.#txPending.add(tx);\n        this.#txComplete = new Promise((resolve, reject) => {\n          tx.addEventListener('complete', () => {\n            this.log?.('IDBTransaction complete');\n            this.#txPending.delete(tx);\n            resolve();\n          });\n          tx.addEventListener('abort', () => {\n            this.#txPending.delete(tx);\n            reject(new Error('transaction aborted'));\n          });\n        });\n      }\n\n      // @ts-ignore\n      // Create object store proxies.\n      const objectStores = [...tx.objectStoreNames].map(name => {\n        return [name, this.proxyStoreOrIndex(tx.objectStore(name))];\n      });\n\n      try {\n        // Execute the function.\n        return await f(Object.fromEntries(objectStores));\n      } catch (e) {\n        // Use a new transaction if this one was inactive. This will\n        // happen if the last request in the transaction completed\n        // in a previous task but the transaction has not yet committed.\n        if (!i && e.name === 'TransactionInactiveError') {\n          this.log?.('TransactionInactiveError, retrying');\n          tx = null;\n          continue;\n        }\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Object store methods that return an IDBRequest, except for cursor\n   * creation, are wrapped to return a Promise. In addition, the\n   * request is used internally for chaining.\n   * @param {IDBObjectStore} objectStore \n   * @returns \n   */\n  proxyStoreOrIndex(objectStore) {\n    return new Proxy(objectStore, {\n      get: (target, property, receiver) => {\n        const result = Reflect.get(target, property, receiver);\n        if (typeof result === 'function') {\n          return (...args) => {\n            const maybeRequest = Reflect.apply(result, target, args);\n            // @ts-ignore\n            if (maybeRequest instanceof IDBRequest && !property.endsWith('Cursor')) {\n              // // Debug logging.\n              // this.log?.(`${target.name}.${String(property)}`, args);\n              // maybeRequest.addEventListener('success', () => {\n              //   this.log?.(`${target.name}.${String(property)} success`, maybeRequest.result);\n              // });\n              // maybeRequest.addEventListener('error', () => {\n              //   this.log?.(`${target.name}.${String(property)} error`, maybeRequest.error);\n              // });\n              \n              // Save the request.\n              this.#request = maybeRequest;\n\n              // Abort the transaction on error.\n              maybeRequest.addEventListener('error', () => {\n                console.error(maybeRequest.error);\n                maybeRequest.transaction.abort();\n              }, { once: true });              \n\n              // Return a Promise.\n              return wrap(maybeRequest);\n            }\n            return maybeRequest;\n          }\n        }\n        return result;\n      }\n    });\n  }\n\n  /**\n   * @param {boolean} durable \n   */\n  async sync(durable) {\n    if (this.#chain) {\n      // This waits for all IndexedDB calls to be made.\n      await this.#chain;\n      if (durable) {\n        // This waits for the final transaction to commit.\n        await this.#txComplete;\n      }\n      this.reset();\n    }\n  }\n\n  reset() {\n    this.#chain = null;\n    this.#txComplete = Promise.resolve();\n    this.#request = null;\n  }\n}\n\n/**\n * @param {IDBRequest} request \n * @returns {Promise}\n */\nfunction wrap(request) {\n  return new Promise((resolve, reject) => {\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\n"],"names":["DEFAULT_SECTOR_SIZE","Base","name","module","methodName","pVfs","zName","pFile","flags","pOutFlags","VFS.SQLITE_CANTOPEN","syncDir","VFS.SQLITE_OK","pResOut","nOut","zOut","nBuf","zBuf","pData","iAmt","iOffsetLo","iOffsetHi","sizeLo","sizeHi","pSize","lockType","op","pArg","VFS.SQLITE_NOTFOUND","AsyncFunction","FacadeVFS","VFS.Base","jMethodName","filename","read","written","VFS.SQLITE_IOERR","iOffset","VFS.SQLITE_IOERR_SHORT_READ","VFS.SQLITE_IOERR_WRITE","size","#decodeFilename","pOutFlagsView","#makeTypedDataView","pResOutView","zOutArray","zBufArray","pDataArray","#makeDataArray","delegalize","pSizeView","pArgView","type","byteOffset","byteLength","getter","setter","makeDataView","dataView","_","prop","littleEndian","value","result","target","receiver","VFS.SQLITE_OPEN_URI","pName","state","charCodes","charCode","lo32","hi32","SHARED","POLL_SHARED","POLL_EXCLUSIVE","POLICIES","WebLocksMixin","superclass","#options","#mapIdToState","options","fileId","VFS.SQLITE_LOCK_NONE","lockState","#lockExclusive","#lockShared","e","VFS.SQLITE_IOERR_LOCK","#unlockExclusive","#unlockShared","VFS.SQLITE_IOERR_UNLOCK","#checkReservedExclusive","#checkReservedShared","VFS.SQLITE_IOERR_CHECKRESERVEDLOCK","#acquire","VFS.SQLITE_BUSY","VFS.SQLITE_LOCK_SHARED","VFS.SQLITE_LOCK_RESERVED","VFS.SQLITE_LOCK_EXCLUSIVE","resolve","controller","lockName","lock","release","File","path","metadata","IDBBatchAtomicVFS","#isReady","#idb","vfs","#initialize","IDBContext","pathname","meta","VFS.SQLITE_OPEN_CREATE","file","blocks","range","VFS.SQLITE_IOERR_DELETE","VFS.SQLITE_IOERR_ACCESS","VFS.SQLITE_OPEN_DELETEONCLOSE","VFS.SQLITE_IOERR_CLOSE","pDataOffset","fileOffset","block","dst","srcOffset","nBytesToCopy","VFS.SQLITE_IOERR_READ","VFS.SQLITE_OPEN_MAIN_DB","pending","data","version","VFS.SQLITE_OPEN_TEMP_DB","iSize","VFS.SQLITE_IOERR_TRUNCATE","VFS.SQLITE_IOERR_FSYNC","pSize64","VFS.SQLITE_IOERR_FSTAT","m","reject","request","cursor","VFS.SQLITE_FCNTL_PRAGMA","key","extractString","setPragmaResponse","response","encoded","out","VFS.SQLITE_ERROR","VFS.SQLITE_FCNTL_SYNC","commitMetadata","prevFileSize","offset","VFS.SQLITE_FCNTL_BEGIN_ATOMIC_WRITE","VFS.SQLITE_FCNTL_COMMIT_ATOMIC_WRITE","VFS.SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE","rollbackMetadata","VFS.SQLITE_IOCAP_BATCH_ATOMIC","VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN","outputArray","p","chars","#database","#chain","#txComplete","#request","#txPending","database","event","db","tx","lastBlock","f","mode","txMode","txOptions","#q","i","objectStores","objectStore","property","args","maybeRequest","wrap","durable"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}