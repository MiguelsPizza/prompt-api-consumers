import{_ as Wn,__tla as Gn}from"./index-BWjLG_JZ.js";let ln,l,q,J,Ie,ie,Et,F,ee,_,Y,k,D,V,te,Z,s,oe,se,v,H,R,Ot,$t,It,fe,_t,Lt,Ut,Xn=Promise.all([(()=>{try{return Gn}catch{}})()]).then(async()=>{var an;const Tt=new WeakMap,ue={ArrayBuffer:"[object ArrayBuffer]",SharedArrayBuffer:"[object SharedArrayBuffer]",Uint8Array:"[object Uint8Array]",RegExp:"[object RegExp]",Map:"[object Map]",Date:"[object Date]"};function we(e){let t=Tt.get(e);return t||(t=Object.prototype.toString.call(e),e!==null&&typeof e=="object"&&Tt.set(e,t)),t}function Fe(e){const t=we(e);return t===ue.ArrayBuffer||t===ue.SharedArrayBuffer}function ae(e){return we(e)===ue.Uint8Array}function le(e){return we(e)===ue.RegExp}function Me(e){return we(e)===ue.Map}function he(e){return we(e)===ue.Date}function M(e,t){return JSON.stringify(e,(r,n)=>typeof n=="bigint"?{$numberLong:`${n}`}:Me(n)?Object.fromEntries(n):n)}function hn(e){if(e!=null&&typeof e=="object"&&"stylize"in e&&typeof e.stylize=="function")return e.stylize}let K,ne,ce,ge,ze,Je,Ve,He,_e,Ce,Le,qe,Ue,vt,ke,Pe,Ye,Te,Be,At,ve,Ze,Ke,be,We,Ae,Ge,Xe,Qe,jt,Se;K=6,ne=Symbol.for("@@mdb.bson.version"),ce=2147483647,ge=-2147483648,ze=Math.pow(2,63)-1,Je=-Math.pow(2,63),Ve=Math.pow(2,53),He=-Math.pow(2,53),_e=1,Ce=2,Le=3,qe=4,Ue=5,vt=6,ke=7,Pe=8,Ye=9,Te=10,Be=11,At=12,ve=13,Ze=14,Ke=15,be=16,We=17,Ae=18,Ge=19,Xe=255,Qe=127,jt=0,Se=4,Et=Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127}),l=class extends Error{get bsonError(){return!0}get name(){return"BSONError"}constructor(e,t){super(e,t)}static isBSONError(e){return e!=null&&typeof e=="object"&&"bsonError"in e&&e.bsonError===!0&&"name"in e&&"message"in e&&"stack"in e}},ee=class extends l{get name(){return"BSONVersionError"}constructor(){super(`Unsupported BSON version, bson types must be from bson ${K}.x.x`)}},Ie=class extends l{get name(){return"BSONRuntimeError"}constructor(e){super(e)}},q=class extends l{get name(){return"BSONOffsetError"}constructor(e,t,r){super(`${e}. offset: ${t}`,r),this.offset=t}};let Rt,Dt;function Ft(e,t,r,n){if(n){Rt??(Rt=new TextDecoder("utf8",{fatal:!0}));try{return Rt.decode(e.subarray(t,r))}catch(i){throw new l("Invalid UTF-8 string in BSON document",{cause:i})}}return Dt??(Dt=new TextDecoder("utf8",{fatal:!1})),Dt.decode(e.subarray(t,r))}function Mt(e,t,r){if(e.length===0)return"";const n=r-t;if(n===0)return"";if(n>20)return null;if(n===1&&e[t]<128)return String.fromCharCode(e[t]);if(n===2&&e[t]<128&&e[t+1]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1]);if(n===3&&e[t]<128&&e[t+1]<128&&e[t+2]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1])+String.fromCharCode(e[t+2]);const i=[];for(let f=t;f<r;f++){const h=e[f];if(h>127)return null;i.push(h)}return String.fromCharCode(...i)}function cn(e,t,r){if(t.length===0)return 0;if(t.length>25||e.length-r<t.length)return null;for(let n=0,i=r;n<t.length;n++,i++){const f=t.charCodeAt(n);if(f>127)return null;e[i]=f}return t.length}function gn(e){return W.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const bn=await(async()=>{try{return(await Wn(async()=>{const{randomBytes:e}=await Promise.resolve().then(()=>Zn);return{randomBytes:e}},void 0)).randomBytes}catch{return gn}})(),W={toLocalBufferType(e){if(Buffer.isBuffer(e))return e;if(ArrayBuffer.isView(e))return Buffer.from(e.buffer,e.byteOffset,e.byteLength);const t=(e==null?void 0:e[Symbol.toStringTag])??Object.prototype.toString.call(e);if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return Buffer.from(e);throw new l(`Cannot create Buffer from ${String(e)}`)},allocate(e){return Buffer.alloc(e)},allocateUnsafe(e){return Buffer.allocUnsafe(e)},equals(e,t){return W.toLocalBufferType(e).equals(t)},fromNumberArray(e){return Buffer.from(e)},fromBase64(e){return Buffer.from(e,"base64")},toBase64(e){return W.toLocalBufferType(e).toString("base64")},fromISO88591(e){return Buffer.from(e,"binary")},toISO88591(e){return W.toLocalBufferType(e).toString("binary")},fromHex(e){return Buffer.from(e,"hex")},toHex(e){return W.toLocalBufferType(e).toString("hex")},toUTF8(e,t,r,n){const i=r-t<=20?Mt(e,t,r):null;if(i!=null)return i;const f=W.toLocalBufferType(e).toString("utf8",t,r);if(n){for(let h=0;h<f.length;h++)if(f.charCodeAt(h)===65533){Ft(e,t,r,!0);break}}return f},utf8ByteLength(e){return Buffer.byteLength(e,"utf8")},encodeUTF8Into(e,t,r){return cn(e,t,r)??W.toLocalBufferType(e).write(t,r,void 0,"utf8")},randomBytes:bn};function mn(){const{navigator:e}=globalThis;return typeof e=="object"&&e.product==="ReactNative"}function dn(e){if(e<0)throw new RangeError(`The argument 'byteLength' is invalid. Received ${e}`);return Ne.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const pn=(()=>{var t;const{crypto:e}=globalThis;if(e!=null&&typeof e.getRandomValues=="function")return r=>e.getRandomValues(Ne.allocate(r));if(mn()){const{console:r}=globalThis;(t=r==null?void 0:r.warn)==null||t.call(r,"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return dn})(),zt=/(\d|[a-f])/i,Ne={toLocalBufferType(e){const t=(e==null?void 0:e[Symbol.toStringTag])??Object.prototype.toString.call(e);if(t==="Uint8Array")return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength));if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return new Uint8Array(e);throw new l(`Cannot make a Uint8Array from ${String(e)}`)},allocate(e){if(typeof e!="number")throw new TypeError(`The "size" argument must be of type number. Received ${String(e)}`);return new Uint8Array(e)},allocateUnsafe(e){return Ne.allocate(e)},equals(e,t){if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0},fromNumberArray(e){return Uint8Array.from(e)},fromBase64(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))},toBase64(e){return btoa(Ne.toISO88591(e))},fromISO88591(e){return Uint8Array.from(e,t=>t.charCodeAt(0)&255)},toISO88591(e){return Array.from(Uint16Array.from(e),t=>String.fromCharCode(t)).join("")},fromHex(e){const t=e.length%2===0?e:e.slice(0,e.length-1),r=[];for(let n=0;n<t.length;n+=2){const i=t[n],f=t[n+1];if(!zt.test(i)||!zt.test(f))break;const h=Number.parseInt(`${i}${f}`,16);r.push(h)}return Uint8Array.from(r)},toHex(e){return Array.from(e,t=>t.toString(16).padStart(2,"0")).join("")},toUTF8(e,t,r,n){return(r-t<=20?Mt(e,t,r):null)??Ft(e,t,r,n)},utf8ByteLength(e){return new TextEncoder().encode(e).byteLength},encodeUTF8Into(e,t,r){const n=new TextEncoder().encode(t);return e.set(n,r),n.byteLength},randomBytes:pn},yn=typeof Buffer=="function"&&((an=Buffer.prototype)==null?void 0:an._isBuffer)!==!0,u=yn?W:Ne;F=class{get[ne](){return K}[Symbol.for("nodejs.util.inspect.custom")](e,t,r){return this.inspect(e,t,r)}},_=class extends F{get _bsontype(){return"Binary"}constructor(e,t){if(super(),e!=null&&typeof e=="string"&&!ArrayBuffer.isView(e)&&!Fe(e)&&!Array.isArray(e))throw new l("Binary can only be constructed from Uint8Array or number[]");this.sub_type=t??_.BSON_BINARY_SUBTYPE_DEFAULT,e==null?(this.buffer=u.allocate(_.BUFFER_SIZE),this.position=0):(this.buffer=Array.isArray(e)?u.fromNumberArray(e):u.toLocalBufferType(e),this.position=this.buffer.byteLength)}put(e){if(typeof e=="string"&&e.length!==1)throw new l("only accepts single character String");if(typeof e!="number"&&e.length!==1)throw new l("only accepts single character Uint8Array or Array");let t;if(typeof e=="string"?t=e.charCodeAt(0):typeof e=="number"?t=e:t=e[0],t<0||t>255)throw new l("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.byteLength>this.position)this.buffer[this.position++]=t;else{const r=u.allocate(_.BUFFER_SIZE+this.buffer.length);r.set(this.buffer,0),this.buffer=r,this.buffer[this.position++]=t}}write(e,t){if(t=typeof t=="number"?t:this.position,this.buffer.byteLength<t+e.length){const r=u.allocate(this.buffer.byteLength+e.length);r.set(this.buffer,0),this.buffer=r}if(ArrayBuffer.isView(e))this.buffer.set(u.toLocalBufferType(e),t),this.position=t+e.byteLength>this.position?t+e.length:this.position;else if(typeof e=="string")throw new l("input cannot be string")}read(e,t){return t=t&&t>0?t:this.position,this.buffer.slice(e,e+t)}value(){return this.buffer.length===this.position?this.buffer:this.buffer.subarray(0,this.position)}length(){return this.position}toJSON(){return u.toBase64(this.buffer.subarray(0,this.position))}toString(e){return e==="hex"?u.toHex(this.buffer.subarray(0,this.position)):e==="base64"?u.toBase64(this.buffer.subarray(0,this.position)):e==="utf8"||e==="utf-8"?u.toUTF8(this.buffer,0,this.position,!1):u.toUTF8(this.buffer,0,this.position,!1)}toExtendedJSON(e){e=e||{};const t=u.toBase64(this.buffer),r=Number(this.sub_type).toString(16);return e.legacy?{$binary:t,$type:r.length===1?"0"+r:r}:{$binary:{base64:t,subType:r.length===1?"0"+r:r}}}toUUID(){if(this.sub_type===_.SUBTYPE_UUID)return new R(this.buffer.slice(0,this.position));throw new l(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_.SUBTYPE_UUID}" is currently supported.`)}static createFromHexString(e,t){return new _(u.fromHex(e),t)}static createFromBase64(e,t){return new _(u.fromBase64(e),t)}static fromExtendedJSON(e,t){t=t||{};let r,n;if("$binary"in e?t.legacy&&typeof e.$binary=="string"&&"$type"in e?(n=e.$type?parseInt(e.$type,16):0,r=u.fromBase64(e.$binary)):typeof e.$binary!="string"&&(n=e.$binary.subType?parseInt(e.$binary.subType,16):0,r=u.fromBase64(e.$binary.base64)):"$uuid"in e&&(n=4,r=R.bytesFromString(e.$uuid)),!r)throw new l(`Unexpected Binary Extended JSON format ${JSON.stringify(e)}`);return n===Se?new R(r):new _(r,n)}inspect(e,t,r){r??(r=M);const n=u.toBase64(this.buffer.subarray(0,this.position)),i=r(n,t),f=r(this.sub_type,t);return`Binary.createFromBase64(${i}, ${f})`}},_.BSON_BINARY_SUBTYPE_DEFAULT=0,_.BUFFER_SIZE=256,_.SUBTYPE_DEFAULT=0,_.SUBTYPE_FUNCTION=1,_.SUBTYPE_BYTE_ARRAY=2,_.SUBTYPE_UUID_OLD=3,_.SUBTYPE_UUID=4,_.SUBTYPE_MD5=5,_.SUBTYPE_ENCRYPTED=6,_.SUBTYPE_COLUMN=7,_.SUBTYPE_SENSITIVE=8,_.SUBTYPE_USER_DEFINED=128;const et=16,wn=/^[0-9A-F]{32}$/i,Bn=/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;R=class extends _{constructor(e){let t;if(e==null)t=R.generate();else if(e instanceof R)t=u.toLocalBufferType(new Uint8Array(e.buffer));else if(ArrayBuffer.isView(e)&&e.byteLength===et)t=u.toLocalBufferType(e);else if(typeof e=="string")t=R.bytesFromString(e);else throw new l("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");super(t,Se)}get id(){return this.buffer}set id(e){this.buffer=e}toHexString(e=!0){return e?[u.toHex(this.buffer.subarray(0,4)),u.toHex(this.buffer.subarray(4,6)),u.toHex(this.buffer.subarray(6,8)),u.toHex(this.buffer.subarray(8,10)),u.toHex(this.buffer.subarray(10,16))].join("-"):u.toHex(this.buffer)}toString(e){return e==="hex"?u.toHex(this.id):e==="base64"?u.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}equals(e){if(!e)return!1;if(e instanceof R)return u.equals(e.id,this.id);try{return u.equals(new R(e).id,this.id)}catch{return!1}}toBinary(){return new _(this.id,_.SUBTYPE_UUID)}static generate(){const e=u.randomBytes(et);return e[6]=e[6]&15|64,e[8]=e[8]&63|128,e}static isValid(e){return e?typeof e=="string"?R.isValidUUIDString(e):ae(e)?e.byteLength===et:e._bsontype==="Binary"&&e.sub_type===this.SUBTYPE_UUID&&e.buffer.byteLength===16:!1}static createFromHexString(e){const t=R.bytesFromString(e);return new R(t)}static createFromBase64(e){return new R(u.fromBase64(e))}static bytesFromString(e){if(!R.isValidUUIDString(e))throw new l("UUID string representation must be 32 hex digits or canonical hyphenated representation");return u.fromHex(e.replace(/-/g,""))}static isValidUUIDString(e){return wn.test(e)||Bn.test(e)}inspect(e,t,r){return r??(r=M),`new UUID(${r(this.toHexString(),t)})`}},Y=class extends F{get _bsontype(){return"Code"}constructor(e,t){super(),this.code=e.toString(),this.scope=t??null}toJSON(){return this.scope!=null?{code:this.code,scope:this.scope}:{code:this.code}}toExtendedJSON(){return this.scope?{$code:this.code,$scope:this.scope}:{$code:this.code}}static fromExtendedJSON(e){return new Y(e.$code,e.$scope)}inspect(e,t,r){r??(r=M);let n=r(this.code,t);const i=n.includes(`
`);this.scope!=null&&(n+=`,${i?`
`:" "}${r(this.scope,t)}`);const f=i&&this.scope===null;return`new Code(${i?`
`:""}${n}${f?`
`:""})`}};function Jt(e){return e!=null&&typeof e=="object"&&"$id"in e&&e.$id!=null&&"$ref"in e&&typeof e.$ref=="string"&&(!("$db"in e)||"$db"in e&&typeof e.$db=="string")}k=class extends F{get _bsontype(){return"DBRef"}constructor(e,t,r,n){super();const i=e.split(".");i.length===2&&(r=i.shift(),e=i.shift()),this.collection=e,this.oid=t,this.db=r,this.fields=n||{}}get namespace(){return this.collection}set namespace(e){this.collection=e}toJSON(){const e=Object.assign({$ref:this.collection,$id:this.oid},this.fields);return this.db!=null&&(e.$db=this.db),e}toExtendedJSON(e){e=e||{};let t={$ref:this.collection,$id:this.oid};return e.legacy||(this.db&&(t.$db=this.db),t=Object.assign(t,this.fields)),t}static fromExtendedJSON(e){const t=Object.assign({},e);return delete t.$ref,delete t.$id,delete t.$db,new k(e.$ref,e.$id,e.$db,t)}inspect(e,t,r){r??(r=M);const n=[r(this.namespace,t),r(this.oid,t),...this.db?[r(this.db,t)]:[],...Object.keys(this.fields).length>0?[r(this.fields,t)]:[]];return n[1]=r===M?`new ObjectId(${n[1]})`:n[1],`new DBRef(${n.join(", ")})`}};function Vt(e){if(e==="")return e;let t=0;const r=e[t]==="-",n=e[t]==="+";(n||r)&&(t+=1);let i=!1;for(;t<e.length&&e[t]==="0";++t)i=!0;return i?`${r?"-":""}${e.length===t?"0":e.slice(t)}`:n?e.slice(1):e}function Sn(e,t){t=t??10;const r="0123456789abcdefghijklmnopqrstuvwxyz".slice(0,t);return new RegExp(`[^-+${r}]`,"i").test(e)?!1:e}let z;try{z=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}const Ht=65536,Nn=1<<24,me=Ht*Ht,Ct=me*me,qt=Ct/2,kt={},Pt={},xn=20,En=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;s=class extends F{get _bsontype(){return"Long"}get __isLong__(){return!0}constructor(e=0,t,r){super();const n=typeof t=="boolean"?t:!!r,i=typeof t=="number"?t:0,f=typeof e=="string"?s.fromString(e,n):typeof e=="bigint"?s.fromBigInt(e,n):{low:e|0,high:i|0,unsigned:n};this.low=f.low,this.high=f.high,this.unsigned=f.unsigned}static fromBits(e,t,r){return new s(e,t,r)}static fromInt(e,t){let r,n,i;return t?(e>>>=0,(i=0<=e&&e<256)&&(n=Pt[e],n)?n:(r=s.fromBits(e,(e|0)<0?-1:0,!0),i&&(Pt[e]=r),r)):(e|=0,(i=-128<=e&&e<128)&&(n=kt[e],n)?n:(r=s.fromBits(e,e<0?-1:0,!1),i&&(kt[e]=r),r))}static fromNumber(e,t){if(isNaN(e))return t?s.UZERO:s.ZERO;if(t){if(e<0)return s.UZERO;if(e>=Ct)return s.MAX_UNSIGNED_VALUE}else{if(e<=-qt)return s.MIN_VALUE;if(e+1>=qt)return s.MAX_VALUE}return e<0?s.fromNumber(-e,t).neg():s.fromBits(e%me|0,e/me|0,t)}static fromBigInt(e,t){const r=BigInt(4294967295),n=BigInt(32);return new s(Number(e&r),Number(e>>n&r),t)}static _fromString(e,t,r){if(e.length===0)throw new l("empty string");if(r<2||36<r)throw new l("radix");let n;if((n=e.indexOf("-"))>0)throw new l("interior hyphen");if(n===0)return s._fromString(e.substring(1),t,r).neg();const i=s.fromNumber(Math.pow(r,8));let f=s.ZERO;for(let h=0;h<e.length;h+=8){const m=Math.min(8,e.length-h),o=parseInt(e.substring(h,h+m),r);if(m<8){const d=s.fromNumber(Math.pow(r,m));f=f.mul(d).add(s.fromNumber(o))}else f=f.mul(i),f=f.add(s.fromNumber(o))}return f.unsigned=t,f}static fromStringStrict(e,t,r){let n=!1;if(typeof t=="number"?(r=t,t=!1):n=!!t,r??(r=10),e.trim()!==e)throw new l(`Input: '${e}' contains leading and/or trailing whitespace`);if(!Sn(e,r))throw new l(`Input: '${e}' contains invalid characters for radix: ${r}`);const i=Vt(e),f=s._fromString(i,n,r);if(f.toString(r).toLowerCase()!==i.toLowerCase())throw new l(`Input: ${e} is not representable as ${f.unsigned?"an unsigned":"a signed"} 64-bit Long ${r!=null?`with radix: ${r}`:""}`);return f}static fromString(e,t,r){let n=!1;return typeof t=="number"?(r=t,t=!1):n=!!t,r??(r=10),e==="NaN"&&r<24||(e==="Infinity"||e==="+Infinity"||e==="-Infinity")&&r<35?s.ZERO:s._fromString(e,n,r)}static fromBytes(e,t,r){return r?s.fromBytesLE(e,t):s.fromBytesBE(e,t)}static fromBytesLE(e,t){return new s(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)}static fromBytesBE(e,t){return new s(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}static isLong(e){return e!=null&&typeof e=="object"&&"__isLong__"in e&&e.__isLong__===!0}static fromValue(e,t){return typeof e=="number"?s.fromNumber(e,t):typeof e=="string"?s.fromString(e,t):s.fromBits(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}add(e){s.isLong(e)||(e=s.fromValue(e));const t=this.high>>>16,r=this.high&65535,n=this.low>>>16,i=this.low&65535,f=e.high>>>16,h=e.high&65535,m=e.low>>>16,o=e.low&65535;let d=0,c=0,a=0,g=0;return g+=i+o,a+=g>>>16,g&=65535,a+=n+m,c+=a>>>16,a&=65535,c+=r+h,d+=c>>>16,c&=65535,d+=t+f,d&=65535,s.fromBits(a<<16|g,d<<16|c,this.unsigned)}and(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low&e.low,this.high&e.high,this.unsigned)}compare(e){if(s.isLong(e)||(e=s.fromValue(e)),this.eq(e))return 0;const t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1}comp(e){return this.compare(e)}divide(e){if(s.isLong(e)||(e=s.fromValue(e)),e.isZero())throw new l("division by zero");if(z){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;const i=(this.unsigned?z.div_u:z.div_s)(this.low,this.high,e.low,e.high);return s.fromBits(i,z.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?s.UZERO:s.ZERO;let t,r,n;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return s.UZERO;if(e.gt(this.shru(1)))return s.UONE;n=s.UZERO}else{if(this.eq(s.MIN_VALUE))return e.eq(s.ONE)||e.eq(s.NEG_ONE)?s.MIN_VALUE:e.eq(s.MIN_VALUE)?s.ONE:(t=this.shr(1).div(e).shl(1),t.eq(s.ZERO)?e.isNegative()?s.ONE:s.NEG_ONE:(r=this.sub(e.mul(t)),n=t.add(r.div(e)),n));if(e.eq(s.MIN_VALUE))return this.unsigned?s.UZERO:s.ZERO;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();n=s.ZERO}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));const i=Math.ceil(Math.log(t)/Math.LN2),f=i<=48?1:Math.pow(2,i-48);let h=s.fromNumber(t),m=h.mul(e);for(;m.isNegative()||m.gt(r);)t-=f,h=s.fromNumber(t,this.unsigned),m=h.mul(e);h.isZero()&&(h=s.ONE),n=n.add(h),r=r.sub(m)}return n}div(e){return this.divide(e)}equals(e){return s.isLong(e)||(e=s.fromValue(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low}eq(e){return this.equals(e)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){if(this.isNegative())return this.eq(s.MIN_VALUE)?64:this.neg().getNumBitsAbs();const e=this.high!==0?this.high:this.low;let t;for(t=31;t>0&&!(e&1<<t);t--);return this.high!==0?t+33:t+1}greaterThan(e){return this.comp(e)>0}gt(e){return this.greaterThan(e)}greaterThanOrEqual(e){return this.comp(e)>=0}gte(e){return this.greaterThanOrEqual(e)}ge(e){return this.greaterThanOrEqual(e)}isEven(){return(this.low&1)===0}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return(this.low&1)===1}isPositive(){return this.unsigned||this.high>=0}isZero(){return this.high===0&&this.low===0}lessThan(e){return this.comp(e)<0}lt(e){return this.lessThan(e)}lessThanOrEqual(e){return this.comp(e)<=0}lte(e){return this.lessThanOrEqual(e)}modulo(e){if(s.isLong(e)||(e=s.fromValue(e)),z){const t=(this.unsigned?z.rem_u:z.rem_s)(this.low,this.high,e.low,e.high);return s.fromBits(t,z.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))}mod(e){return this.modulo(e)}rem(e){return this.modulo(e)}multiply(e){if(this.isZero())return s.ZERO;if(s.isLong(e)||(e=s.fromValue(e)),z){const B=z.mul(this.low,this.high,e.low,e.high);return s.fromBits(B,z.get_high(),this.unsigned)}if(e.isZero())return s.ZERO;if(this.eq(s.MIN_VALUE))return e.isOdd()?s.MIN_VALUE:s.ZERO;if(e.eq(s.MIN_VALUE))return this.isOdd()?s.MIN_VALUE:s.ZERO;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(s.TWO_PWR_24)&&e.lt(s.TWO_PWR_24))return s.fromNumber(this.toNumber()*e.toNumber(),this.unsigned);const t=this.high>>>16,r=this.high&65535,n=this.low>>>16,i=this.low&65535,f=e.high>>>16,h=e.high&65535,m=e.low>>>16,o=e.low&65535;let d=0,c=0,a=0,g=0;return g+=i*o,a+=g>>>16,g&=65535,a+=n*o,c+=a>>>16,a&=65535,a+=i*m,c+=a>>>16,a&=65535,c+=r*o,d+=c>>>16,c&=65535,c+=n*m,d+=c>>>16,c&=65535,c+=i*h,d+=c>>>16,c&=65535,d+=t*o+r*m+n*h+i*f,d&=65535,s.fromBits(a<<16|g,d<<16|c,this.unsigned)}mul(e){return this.multiply(e)}negate(){return!this.unsigned&&this.eq(s.MIN_VALUE)?s.MIN_VALUE:this.not().add(s.ONE)}neg(){return this.negate()}not(){return s.fromBits(~this.low,~this.high,this.unsigned)}notEquals(e){return!this.equals(e)}neq(e){return this.notEquals(e)}ne(e){return this.notEquals(e)}or(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low|e.low,this.high|e.high,this.unsigned)}shiftLeft(e){return s.isLong(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?s.fromBits(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):s.fromBits(0,this.low<<e-32,this.unsigned)}shl(e){return this.shiftLeft(e)}shiftRight(e){return s.isLong(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?s.fromBits(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):s.fromBits(this.high>>e-32,this.high>=0?0:-1,this.unsigned)}shr(e){return this.shiftRight(e)}shiftRightUnsigned(e){if(s.isLong(e)&&(e=e.toInt()),e&=63,e===0)return this;{const t=this.high;if(e<32){const r=this.low;return s.fromBits(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?s.fromBits(t,0,this.unsigned):s.fromBits(t>>>e-32,0,this.unsigned)}}shr_u(e){return this.shiftRightUnsigned(e)}shru(e){return this.shiftRightUnsigned(e)}subtract(e){return s.isLong(e)||(e=s.fromValue(e)),this.add(e.neg())}sub(e){return this.subtract(e)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){return this.unsigned?(this.high>>>0)*me+(this.low>>>0):this.high*me+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(e){return e?this.toBytesLE():this.toBytesBE()}toBytesLE(){const e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]}toBytesBE(){const e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]}toSigned(){return this.unsigned?s.fromBits(this.low,this.high,!1):this}toString(e){if(e=e||10,e<2||36<e)throw new l("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(s.MIN_VALUE)){const i=s.fromNumber(e),f=this.div(i),h=f.mul(i).sub(this);return f.toString(e)+h.toInt().toString(e)}else return"-"+this.neg().toString(e);const t=s.fromNumber(Math.pow(e,6),this.unsigned);let r=this,n="";for(;;){const i=r.div(t);let f=(r.sub(i.mul(t)).toInt()>>>0).toString(e);if(r=i,r.isZero())return f+n;for(;f.length<6;)f="0"+f;n=""+f+n}}toUnsigned(){return this.unsigned?this:s.fromBits(this.low,this.high,!0)}xor(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low^e.low,this.high^e.high,this.unsigned)}eqz(){return this.isZero()}le(e){return this.lessThanOrEqual(e)}toExtendedJSON(e){return e&&e.relaxed?this.toNumber():{$numberLong:this.toString()}}static fromExtendedJSON(e,t){const{useBigInt64:r=!1,relaxed:n=!0}={...t};if(e.$numberLong.length>xn)throw new l("$numberLong string is too long");if(!En.test(e.$numberLong))throw new l(`$numberLong string "${e.$numberLong}" is in an invalid format`);if(r){const f=BigInt(e.$numberLong);return BigInt.asIntN(64,f)}const i=s.fromString(e.$numberLong);return n?i.toNumber():i}inspect(e,t,r){r??(r=M);const n=r(this.toString(),t),i=this.unsigned?`, ${r(this.unsigned,t)}`:"";return`new Long(${n}${i})`}},s.TWO_PWR_24=s.fromInt(Nn),s.MAX_UNSIGNED_VALUE=s.fromBits(-1,-1,!0),s.ZERO=s.fromInt(0),s.UZERO=s.fromInt(0,!0),s.ONE=s.fromInt(1),s.UONE=s.fromInt(1,!0),s.NEG_ONE=s.fromInt(-1),s.MAX_VALUE=s.fromBits(-1,2147483647,!1),s.MIN_VALUE=s.fromBits(0,-2147483648,!1);const On=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/,$n=/^(\+|-)?(Infinity|inf)$/i,In=/^(\+|-)?NaN$/i,de=6111,xe=-6176,Yt=6176,Zt=34,tt=u.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Kt=u.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Wt=u.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),_n=/^([-+])?(\d+)?$/,Ln=31,Gt=16383,Un=30,Tn=31;function Xt(e){return!isNaN(parseInt(e,10))}function vn(e){const t=s.fromNumber(1e9);let r=s.fromNumber(0);if(!e.parts[0]&&!e.parts[1]&&!e.parts[2]&&!e.parts[3])return{quotient:e,rem:r};for(let n=0;n<=3;n++)r=r.shiftLeft(32),r=r.add(new s(e.parts[n],0)),e.parts[n]=r.div(t).low,r=r.modulo(t);return{quotient:e,rem:r}}function An(e,t){if(!e&&!t)return{high:s.fromNumber(0),low:s.fromNumber(0)};const r=e.shiftRightUnsigned(32),n=new s(e.getLowBits(),0),i=t.shiftRightUnsigned(32),f=new s(t.getLowBits(),0);let h=r.multiply(i),m=r.multiply(f);const o=n.multiply(i);let d=n.multiply(f);return h=h.add(m.shiftRightUnsigned(32)),m=new s(m.getLowBits(),0).add(o).add(d.shiftRightUnsigned(32)),h=h.add(m.shiftRightUnsigned(32)),d=m.shiftLeft(32).add(new s(d.getLowBits(),0)),{high:h,low:d}}function jn(e,t){const r=e.high>>>0,n=t.high>>>0;if(r<n)return!0;if(r===n){const i=e.low>>>0,f=t.low>>>0;if(i<f)return!0}return!1}function C(e,t){throw new l(`"${e}" is not a valid Decimal128 string - ${t}`)}D=class extends F{get _bsontype(){return"Decimal128"}constructor(e){if(super(),typeof e=="string")this.bytes=D.fromString(e).bytes;else if(e instanceof Uint8Array||ae(e)){if(e.byteLength!==16)throw new l("Decimal128 must take a Buffer of 16 bytes");this.bytes=e}else throw new l("Decimal128 must take a Buffer or string")}static fromString(e){return D._fromString(e,{allowRounding:!1})}static fromStringWithRounding(e){return D._fromString(e,{allowRounding:!0})}static _fromString(e,t){let r=!1,n=!1,i=!1,f=!1,h=0,m=0,o=0,d=0,c=0;const a=[0];let g=0,B=0,b=0,O=0,j=new s(0,0),A=new s(0,0),L=0,x=0;if(e.length>=7e3)throw new l(""+e+" not a valid Decimal128 string");const X=e.match(On),Oe=e.match($n),$=e.match(In);if(!X&&!Oe&&!$||e.length===0)throw new l(""+e+" not a valid Decimal128 string");if(X){const y=X[2],p=X[4],S=X[5],E=X[6];p&&E===void 0&&C(e,"missing exponent power"),p&&y===void 0&&C(e,"missing exponent base"),p===void 0&&(S||E)&&C(e,"missing e before exponent")}if((e[x]==="+"||e[x]==="-")&&(n=!0,r=e[x++]==="-"),!Xt(e[x])&&e[x]!=="."){if(e[x]==="i"||e[x]==="I")return new D(r?Kt:Wt);if(e[x]==="N")return new D(tt)}for(;Xt(e[x])||e[x]===".";){if(e[x]==="."){i&&C(e,"contains multiple periods"),i=!0,x=x+1;continue}g<Zt&&(e[x]!=="0"||f)&&(f||(c=m),f=!0,a[B++]=parseInt(e[x],10),g=g+1),f&&(o=o+1),i&&(d=d+1),m=m+1,x=x+1}if(i&&!m)throw new l(""+e+" not a valid Decimal128 string");if(e[x]==="e"||e[x]==="E"){const y=e.substr(++x).match(_n);if(!y||!y[2])return new D(tt);O=parseInt(y[0],10),x=x+y[0].length}if(e[x])return new D(tt);if(!g)a[0]=0,o=1,g=1,h=0;else if(b=g-1,h=o,h!==1)for(;e[c+h-1+Number(n)+Number(i)]==="0";)h=h-1;for(O<=d&&d>O+16384?O=xe:O=O-d;O>de;){if(b=b+1,b>=Zt){if(h===0){O=de;break}C(e,"overflow")}O=O-1}if(t.allowRounding){for(;O<xe||g<o;){if(b===0&&h<g){O=xe,h=0;break}if(g<o?o=o-1:b=b-1,O<de)O=O+1;else{if(a.join("").match(/^0+$/)){O=de;break}C(e,"overflow")}}if(b+1<h){let y=m;i&&(c=c+1,y=y+1),n&&(c=c+1,y=y+1);const p=parseInt(e[c+b+1],10);let S=0;if(p>=5&&(S=1,p===5)){S=a[b]%2===1?1:0;for(let E=c+b+2;E<y;E++)if(parseInt(e[E],10)){S=1;break}}if(S){let E=b;for(;E>=0&&++a[E]>9;E--)if(a[E]=0,E===0)if(O<de)O=O+1,a[E]=1;else return new D(r?Kt:Wt)}}}else{for(;O<xe||g<o;){if(b===0){if(h===0){O=xe;break}C(e,"exponent underflow")}g<o?(e[o-1+Number(n)+Number(i)]!=="0"&&h!==0&&C(e,"inexact rounding"),o=o-1):(a[b]!==0&&C(e,"inexact rounding"),b=b-1),O<de?O=O+1:C(e,"overflow")}b+1<h&&(i&&(c=c+1),n&&(c=c+1),parseInt(e[c+b+1],10)!==0&&C(e,"inexact rounding"))}if(j=s.fromNumber(0),A=s.fromNumber(0),h===0)j=s.fromNumber(0),A=s.fromNumber(0);else if(b<17){let y=0;for(A=s.fromNumber(a[y++]),j=new s(0,0);y<=b;y++)A=A.multiply(s.fromNumber(10)),A=A.add(s.fromNumber(a[y]))}else{let y=0;for(j=s.fromNumber(a[y++]);y<=b-17;y++)j=j.multiply(s.fromNumber(10)),j=j.add(s.fromNumber(a[y]));for(A=s.fromNumber(a[y++]);y<=b;y++)A=A.multiply(s.fromNumber(10)),A=A.add(s.fromNumber(a[y]))}const w=An(j,s.fromString("100000000000000000"));w.low=w.low.add(A),jn(w.low,A)&&(w.high=w.high.add(s.fromNumber(1))),L=O+Yt;const I={low:s.fromNumber(0),high:s.fromNumber(0)};w.high.shiftRightUnsigned(49).and(s.fromNumber(1)).equals(s.fromNumber(1))?(I.high=I.high.or(s.fromNumber(3).shiftLeft(61)),I.high=I.high.or(s.fromNumber(L).and(s.fromNumber(16383).shiftLeft(47))),I.high=I.high.or(w.high.and(s.fromNumber(0x7fffffffffff)))):(I.high=I.high.or(s.fromNumber(L&16383).shiftLeft(49)),I.high=I.high.or(w.high.and(s.fromNumber(562949953421311)))),I.low=w.low,r&&(I.high=I.high.or(s.fromString("9223372036854775808")));const T=u.allocateUnsafe(16);return x=0,T[x++]=I.low.low&255,T[x++]=I.low.low>>8&255,T[x++]=I.low.low>>16&255,T[x++]=I.low.low>>24&255,T[x++]=I.low.high&255,T[x++]=I.low.high>>8&255,T[x++]=I.low.high>>16&255,T[x++]=I.low.high>>24&255,T[x++]=I.high.low&255,T[x++]=I.high.low>>8&255,T[x++]=I.high.low>>16&255,T[x++]=I.high.low>>24&255,T[x++]=I.high.high&255,T[x++]=I.high.high>>8&255,T[x++]=I.high.high>>16&255,T[x++]=I.high.high>>24&255,new D(T)}toString(){let e,t=0;const r=new Array(36);for(let L=0;L<r.length;L++)r[L]=0;let n=0,i=!1,f,h={parts:[0,0,0,0]},m,o;const d=[];n=0;const c=this.bytes,a=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,g=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,B=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,b=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24;n=0,{low:new s(a,g),high:new s(B,b)}.high.lessThan(s.ZERO)&&d.push("-");const O=b>>26&Ln;if(O>>3===3){if(O===Un)return d.join("")+"Infinity";if(O===Tn)return"NaN";e=b>>15&Gt,f=8+(b>>14&1)}else f=b>>14&7,e=b>>17&Gt;const j=e-Yt;if(h.parts[0]=(b&16383)+((f&15)<<14),h.parts[1]=B,h.parts[2]=g,h.parts[3]=a,h.parts[0]===0&&h.parts[1]===0&&h.parts[2]===0&&h.parts[3]===0)i=!0;else for(o=3;o>=0;o--){let L=0;const x=vn(h);if(h=x.quotient,L=x.rem.low,!!L)for(m=8;m>=0;m--)r[o*9+m]=L%10,L=Math.floor(L/10)}if(i)t=1,r[n]=0;else for(t=36;!r[n];)t=t-1,n=n+1;const A=t-1+j;if(A>=34||A<=-7||j>0){if(t>34)return d.push("0"),j>0?d.push(`E+${j}`):j<0&&d.push(`E${j}`),d.join("");d.push(`${r[n++]}`),t=t-1,t&&d.push(".");for(let L=0;L<t;L++)d.push(`${r[n++]}`);d.push("E"),A>0?d.push(`+${A}`):d.push(`${A}`)}else if(j>=0)for(let L=0;L<t;L++)d.push(`${r[n++]}`);else{let L=t+j;if(L>0)for(let x=0;x<L;x++)d.push(`${r[n++]}`);else d.push("0");for(d.push(".");L++<0;)d.push("0");for(let x=0;x<t-Math.max(L-1,0);x++)d.push(`${r[n++]}`)}return d.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(e){return D.fromString(e.$numberDecimal)}inspect(e,t,r){return r??(r=M),`new Decimal128(${r(this.toString(),t)})`}},V=class extends F{get _bsontype(){return"Double"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=+e}static fromString(e){const t=Number(e);if(e==="NaN")return new V(NaN);if(e==="Infinity")return new V(1/0);if(e==="-Infinity")return new V(-1/0);if(!Number.isFinite(t))throw new l(`Input: ${e} is not representable as a Double`);if(e.trim()!==e)throw new l(`Input: '${e}' contains whitespace`);if(e==="")throw new l("Input is an empty string");if(/[^-0-9.+eE]/.test(e))throw new l(`Input: '${e}' is not in decimal or exponential notation`);return new V(t)}valueOf(){return this.value}toJSON(){return this.value}toString(e){return this.value.toString(e)}toExtendedJSON(e){return e&&(e.legacy||e.relaxed&&isFinite(this.value))?this.value:Object.is(Math.sign(this.value),-0)?{$numberDouble:"-0.0"}:{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(e,t){const r=parseFloat(e.$numberDouble);return t&&t.relaxed?r:new V(r)}inspect(e,t,r){return r??(r=M),`new Double(${r(this.value,t)})`}},Z=class extends F{get _bsontype(){return"Int32"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=+e|0}static fromString(e){const t=Vt(e),r=Number(e);if(ce<r)throw new l(`Input: '${e}' is larger than the maximum value for Int32`);if(ge>r)throw new l(`Input: '${e}' is smaller than the minimum value for Int32`);if(Number.isSafeInteger(r)){if(r.toString()!==t)throw new l(`Input: '${e}' is not a valid Int32 string`)}else throw new l(`Input: '${e}' is not a safe integer`);return new Z(r)}valueOf(){return this.value}toString(e){return this.value.toString(e)}toJSON(){return this.value}toExtendedJSON(e){return e&&(e.relaxed||e.legacy)?this.value:{$numberInt:this.value.toString()}}static fromExtendedJSON(e,t){return t&&t.relaxed?parseInt(e.$numberInt,10):new Z(e.$numberInt)}inspect(e,t,r){return r??(r=M),`new Int32(${r(this.value,t)})`}},oe=class extends F{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new oe}inspect(){return"new MaxKey()"}},se=class extends F{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new se}inspect(){return"new MinKey()"}};const pe=new Float64Array(1),U=new Uint8Array(pe.buffer,0,8);pe[0]=-1;const Qt=U[7]===0,N={getNonnegativeInt32LE(e,t){if(e[t+3]>127)throw new RangeError(`Size cannot be negative at offset: ${t}`);return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getInt32LE(e,t){return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getUint32LE(e,t){return e[t]+e[t+1]*256+e[t+2]*65536+e[t+3]*16777216},getUint32BE(e,t){return e[t+3]+e[t+2]*256+e[t+1]*65536+e[t]*16777216},getBigInt64LE(e,t){const r=N.getUint32LE(e,t),n=N.getUint32LE(e,t+4);return(BigInt(n)<<BigInt(32))+BigInt(r)},getFloat64LE:Qt?(e,t)=>(U[7]=e[t],U[6]=e[t+1],U[5]=e[t+2],U[4]=e[t+3],U[3]=e[t+4],U[2]=e[t+5],U[1]=e[t+6],U[0]=e[t+7],pe[0]):(e,t)=>(U[0]=e[t],U[1]=e[t+1],U[2]=e[t+2],U[3]=e[t+3],U[4]=e[t+4],U[5]=e[t+5],U[6]=e[t+6],U[7]=e[t+7],pe[0]),setInt32BE(e,t,r){return e[t+3]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t]=r,4},setInt32LE(e,t,r){return e[t]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+3]=r,4},setBigInt64LE(e,t,r){const n=BigInt(4294967295);let i=Number(r&n);e[t]=i,i>>=8,e[t+1]=i,i>>=8,e[t+2]=i,i>>=8,e[t+3]=i;let f=Number(r>>BigInt(32)&n);return e[t+4]=f,f>>=8,e[t+5]=f,f>>=8,e[t+6]=f,f>>=8,e[t+7]=f,8},setFloat64LE:Qt?(e,t,r)=>(pe[0]=r,e[t]=U[7],e[t+1]=U[6],e[t+2]=U[5],e[t+3]=U[4],e[t+4]=U[3],e[t+5]=U[2],e[t+6]=U[1],e[t+7]=U[0],8):(e,t,r)=>(pe[0]=r,e[t]=U[0],e[t+1]=U[1],e[t+2]=U[2],e[t+3]=U[3],e[t+4]=U[4],e[t+5]=U[5],e[t+6]=U[6],e[t+7]=U[7],8)};let re=null;v=class extends F{get _bsontype(){return"ObjectId"}constructor(e){super();let t;if(typeof e=="object"&&e&&"id"in e){if(typeof e.id!="string"&&!ArrayBuffer.isView(e.id))throw new l("Argument passed in must have an id that is of type string or Buffer");"toHexString"in e&&typeof e.toHexString=="function"?t=u.fromHex(e.toHexString()):t=e.id}else t=e;if(t==null||typeof t=="number")this.buffer=v.generate(typeof t=="number"?t:void 0);else if(ArrayBuffer.isView(t)&&t.byteLength===12)this.buffer=u.toLocalBufferType(t);else if(typeof t=="string")if(v.validateHexString(t))this.buffer=u.fromHex(t);else throw new l("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");else throw new l("Argument passed in does not match the accepted types");v.cacheHexString&&(this.__id=u.toHex(this.id))}get id(){return this.buffer}set id(e){this.buffer=e,v.cacheHexString&&(this.__id=u.toHex(e))}static validateHexString(e){if((e==null?void 0:e.length)!==24)return!1;for(let t=0;t<24;t++){const r=e.charCodeAt(t);if(!(r>=48&&r<=57||r>=97&&r<=102||r>=65&&r<=70))return!1}return!0}toHexString(){if(v.cacheHexString&&this.__id)return this.__id;const e=u.toHex(this.id);return v.cacheHexString&&!this.__id&&(this.__id=e),e}static getInc(){return v.index=(v.index+1)%16777215}static generate(e){typeof e!="number"&&(e=Math.floor(Date.now()/1e3));const t=v.getInc(),r=u.allocateUnsafe(12);return N.setInt32BE(r,0,e),re===null&&(re=u.randomBytes(5)),r[4]=re[0],r[5]=re[1],r[6]=re[2],r[7]=re[3],r[8]=re[4],r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r}toString(e){return e==="base64"?u.toBase64(this.id):e==="hex"?this.toHexString():this.toHexString()}toJSON(){return this.toHexString()}static is(e){return e!=null&&typeof e=="object"&&"_bsontype"in e&&e._bsontype==="ObjectId"}equals(e){if(e==null)return!1;if(v.is(e))return this.buffer[11]===e.buffer[11]&&u.equals(this.buffer,e.buffer);if(typeof e=="string")return e.toLowerCase()===this.toHexString();if(typeof e=="object"&&typeof e.toHexString=="function"){const t=e.toHexString(),r=this.toHexString();return typeof t=="string"&&t.toLowerCase()===r}return!1}getTimestamp(){const e=new Date,t=N.getUint32BE(this.buffer,0);return e.setTime(Math.floor(t)*1e3),e}static createPk(){return new v}serializeInto(e,t){return e[t]=this.buffer[0],e[t+1]=this.buffer[1],e[t+2]=this.buffer[2],e[t+3]=this.buffer[3],e[t+4]=this.buffer[4],e[t+5]=this.buffer[5],e[t+6]=this.buffer[6],e[t+7]=this.buffer[7],e[t+8]=this.buffer[8],e[t+9]=this.buffer[9],e[t+10]=this.buffer[10],e[t+11]=this.buffer[11],12}static createFromTime(e){const t=u.allocate(12);for(let r=11;r>=4;r--)t[r]=0;return N.setInt32BE(t,0,e),new v(t)}static createFromHexString(e){if((e==null?void 0:e.length)!==24)throw new l("hex string must be 24 characters");return new v(u.fromHex(e))}static createFromBase64(e){if((e==null?void 0:e.length)!==16)throw new l("base64 string must be 16 characters");return new v(u.fromBase64(e))}static isValid(e){if(e==null)return!1;if(typeof e=="string")return v.validateHexString(e);try{return new v(e),!0}catch{return!1}}toExtendedJSON(){return this.toHexString?{$oid:this.toHexString()}:{$oid:this.toString("hex")}}static fromExtendedJSON(e){return new v(e.$oid)}inspect(e,t,r){return r??(r=M),`new ObjectId(${r(this.toHexString(),t)})`}},v.index=Math.floor(Math.random()*16777215);function je(e,t,r){let n=5;if(Array.isArray(e))for(let i=0;i<e.length;i++)n+=en(i.toString(),e[i],t,!0,r);else{typeof(e==null?void 0:e.toBSON)=="function"&&(e=e.toBSON());for(const i of Object.keys(e))n+=en(i,e[i],t,!1,r)}return n}function en(e,t,r=!1,n=!1,i=!1){switch(typeof(t==null?void 0:t.toBSON)=="function"&&(t=t.toBSON()),typeof t){case"string":return 1+u.utf8ByteLength(e)+1+4+u.utf8ByteLength(t)+1;case"number":return Math.floor(t)===t&&t>=He&&t<=Ve&&t>=ge&&t<=ce?(e!=null?u.utf8ByteLength(e)+1:0)+5:(e!=null?u.utf8ByteLength(e)+1:0)+9;case"undefined":return n||!i?(e!=null?u.utf8ByteLength(e)+1:0)+1:0;case"boolean":return(e!=null?u.utf8ByteLength(e)+1:0)+2;case"object":if(t!=null&&typeof t._bsontype=="string"&&t[ne]!==K)throw new ee;if(t==null||t._bsontype==="MinKey"||t._bsontype==="MaxKey")return(e!=null?u.utf8ByteLength(e)+1:0)+1;if(t._bsontype==="ObjectId")return(e!=null?u.utf8ByteLength(e)+1:0)+13;if(t instanceof Date||he(t))return(e!=null?u.utf8ByteLength(e)+1:0)+9;if(ArrayBuffer.isView(t)||t instanceof ArrayBuffer||Fe(t))return(e!=null?u.utf8ByteLength(e)+1:0)+6+t.byteLength;if(t._bsontype==="Long"||t._bsontype==="Double"||t._bsontype==="Timestamp")return(e!=null?u.utf8ByteLength(e)+1:0)+9;if(t._bsontype==="Decimal128")return(e!=null?u.utf8ByteLength(e)+1:0)+17;if(t._bsontype==="Code")return t.scope!=null&&Object.keys(t.scope).length>0?(e!=null?u.utf8ByteLength(e)+1:0)+1+4+4+u.utf8ByteLength(t.code.toString())+1+je(t.scope,r,i):(e!=null?u.utf8ByteLength(e)+1:0)+1+4+u.utf8ByteLength(t.code.toString())+1;if(t._bsontype==="Binary"){const f=t;return f.sub_type===_.SUBTYPE_BYTE_ARRAY?(e!=null?u.utf8ByteLength(e)+1:0)+(f.position+1+4+1+4):(e!=null?u.utf8ByteLength(e)+1:0)+(f.position+1+4+1)}else{if(t._bsontype==="Symbol")return(e!=null?u.utf8ByteLength(e)+1:0)+u.utf8ByteLength(t.value)+4+1+1;if(t._bsontype==="DBRef"){const f=Object.assign({$ref:t.collection,$id:t.oid},t.fields);return t.db!=null&&(f.$db=t.db),(e!=null?u.utf8ByteLength(e)+1:0)+1+je(f,r,i)}else return t instanceof RegExp||le(t)?(e!=null?u.utf8ByteLength(e)+1:0)+1+u.utf8ByteLength(t.source)+1+(t.global?1:0)+(t.ignoreCase?1:0)+(t.multiline?1:0)+1:t._bsontype==="BSONRegExp"?(e!=null?u.utf8ByteLength(e)+1:0)+1+u.utf8ByteLength(t.pattern)+1+u.utf8ByteLength(t.options)+1:(e!=null?u.utf8ByteLength(e)+1:0)+je(t,r,i)+1}case"function":if(r)return(e!=null?u.utf8ByteLength(e)+1:0)+1+4+u.utf8ByteLength(t.toString())+1}return 0}function Rn(e){return e.split("").sort().join("")}J=class extends F{get _bsontype(){return"BSONRegExp"}constructor(e,t){if(super(),this.pattern=e,this.options=Rn(t??""),this.pattern.indexOf("\0")!==-1)throw new l(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);if(this.options.indexOf("\0")!==-1)throw new l(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);for(let r=0;r<this.options.length;r++)if(!(this.options[r]==="i"||this.options[r]==="m"||this.options[r]==="x"||this.options[r]==="l"||this.options[r]==="s"||this.options[r]==="u"))throw new l(`The regular expression option [${this.options[r]}] is not supported`)}static parseOptions(e){return e?e.split("").sort().join(""):""}toExtendedJSON(e){return e=e||{},e.legacy?{$regex:this.pattern,$options:this.options}:{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(e){if("$regex"in e)if(typeof e.$regex!="string"){if(e.$regex._bsontype==="BSONRegExp")return e}else return new J(e.$regex,J.parseOptions(e.$options));if("$regularExpression"in e)return new J(e.$regularExpression.pattern,J.parseOptions(e.$regularExpression.options));throw new l(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(e)}`)}inspect(e,t,r){const n=hn(t)??(h=>h);r??(r=M);const i=n(r(this.pattern),"regexp"),f=n(r(this.options),"regexp");return`new BSONRegExp(${i}, ${f})`}},ie=class extends F{get _bsontype(){return"BSONSymbol"}constructor(e){super(),this.value=e}valueOf(){return this.value}toString(){return this.value}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(e){return new ie(e.$symbol)}inspect(e,t,r){return r??(r=M),`new BSONSymbol(${r(this.value,t)})`}};const Dn=s;H=class extends Dn{get _bsontype(){return"Timestamp"}get i(){return this.low>>>0}get t(){return this.high>>>0}constructor(e){if(e==null)super(0,0,!0);else if(typeof e=="bigint")super(e,!0);else if(s.isLong(e))super(e.low,e.high,!0);else if(typeof e=="object"&&"t"in e&&"i"in e){if(typeof e.t!="number"&&(typeof e.t!="object"||e.t._bsontype!=="Int32"))throw new l("Timestamp constructed from { t, i } must provide t as a number");if(typeof e.i!="number"&&(typeof e.i!="object"||e.i._bsontype!=="Int32"))throw new l("Timestamp constructed from { t, i } must provide i as a number");const t=Number(e.t),r=Number(e.i);if(t<0||Number.isNaN(t))throw new l("Timestamp constructed from { t, i } must provide a positive t");if(r<0||Number.isNaN(r))throw new l("Timestamp constructed from { t, i } must provide a positive i");if(t>4294967295)throw new l("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");if(r>4294967295)throw new l("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");super(r,t,!0)}else throw new l("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }")}toJSON(){return{$timestamp:this.toString()}}static fromInt(e){return new H(s.fromInt(e,!0))}static fromNumber(e){return new H(s.fromNumber(e,!0))}static fromBits(e,t){return new H({i:e,t})}static fromString(e,t){return new H(s.fromString(e,!0,t))}toExtendedJSON(){return{$timestamp:{t:this.t,i:this.i}}}static fromExtendedJSON(e){const t=s.isLong(e.$timestamp.i)?e.$timestamp.i.getLowBitsUnsigned():e.$timestamp.i,r=s.isLong(e.$timestamp.t)?e.$timestamp.t.getLowBitsUnsigned():e.$timestamp.t;return new H({t:r,i:t})}inspect(e,t,r){r??(r=M);const n=r(this.t,t),i=r(this.i,t);return`new Timestamp({ t: ${n}, i: ${i} })`}},H.MAX_VALUE=s.MAX_UNSIGNED_VALUE;const Fn=s.fromNumber(Ve),Mn=s.fromNumber(He);function tn(e,t,r){t=t??{};const n=t&&t.index?t.index:0,i=N.getInt32LE(e,n);if(i<5)throw new l(`bson size must be >= 5, is ${i}`);if(t.allowObjectSmallerThanBufferSize&&e.length<i)throw new l(`buffer length ${e.length} must be >= bson size ${i}`);if(!t.allowObjectSmallerThanBufferSize&&e.length!==i)throw new l(`buffer length ${e.length} must === bson size ${i}`);if(i+n>e.byteLength)throw new l(`(bson size ${i} + options.index ${n} must be <= buffer length ${e.byteLength})`);if(e[n+i-1]!==0)throw new l("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return Re(e,n,t,r)}const zn=/^\$ref$|^\$id$|^\$db$/;function Re(e,t,r,n=!1){const i=r.fieldsAsRaw==null?null:r.fieldsAsRaw,f=r.raw==null?!1:r.raw,h=typeof r.bsonRegExp=="boolean"?r.bsonRegExp:!1,m=r.promoteBuffers??!1,o=r.promoteLongs??!0,d=r.promoteValues??!0,c=r.useBigInt64??!1;if(c&&!d)throw new l("Must either request bigint or Long for int64 deserialization");if(c&&!o)throw new l("Must either request bigint or Long for int64 deserialization");const a=r.validation==null?{utf8:!0}:r.validation;let g=!0,B,b;const O=a.utf8;if(typeof O=="boolean")B=O;else{g=!1;const $=Object.keys(O).map(function(w){return O[w]});if($.length===0)throw new l("UTF-8 validation setting cannot be empty");if(typeof $[0]!="boolean")throw new l("Invalid UTF-8 validation option, must specify boolean values");if(B=$[0],!$.every(w=>w===B))throw new l("Invalid UTF-8 validation option - keys must be all true or all false")}if(!g){b=new Set;for(const $ of Object.keys(O))b.add($)}const j=t;if(e.length<5)throw new l("corrupt bson message < 5 bytes long");const A=N.getInt32LE(e,t);if(t+=4,A<5||A>e.length)throw new l("corrupt bson message");const L=n?[]:{};let x=0;const X=!1;let Oe=n?!1:null;for(;!X;){const $=e[t++];if($===0)break;let w=t;for(;e[w]!==0&&w<e.length;)w++;if(w>=e.byteLength)throw new l("Bad BSON Document: illegal CString");const I=n?x++:u.toUTF8(e,t,w,!1);let T=!0;g||b!=null&&b.has(I)?T=B:T=!B,Oe!==!1&&I[0]==="$"&&(Oe=zn.test(I));let y;if(t=w+1,$===Ce){const p=N.getInt32LE(e,t);if(t+=4,p<=0||p>e.length-t||e[t+p-1]!==0)throw new l("bad string length in bson");y=u.toUTF8(e,t,t+p-1,T),t=t+p}else if($===ke){const p=u.allocateUnsafe(12);for(let S=0;S<12;S++)p[S]=e[t+S];y=new v(p),t=t+12}else if($===be&&d===!1)y=new Z(N.getInt32LE(e,t)),t+=4;else if($===be)y=N.getInt32LE(e,t),t+=4;else if($===_e)y=N.getFloat64LE(e,t),t+=8,d===!1&&(y=new V(y));else if($===Ye){const p=N.getInt32LE(e,t),S=N.getInt32LE(e,t+4);t+=8,y=new Date(new s(p,S).toNumber())}else if($===Pe){if(e[t]!==0&&e[t]!==1)throw new l("illegal boolean type value");y=e[t++]===1}else if($===Le){const p=t,S=N.getInt32LE(e,t);if(S<=0||S>e.length-t)throw new l("bad embedded document length in bson");if(f)y=e.slice(t,t+S);else{let E=r;g||(E={...r,validation:{utf8:T}}),y=Re(e,p,E,!1)}t=t+S}else if($===qe){const p=t,S=N.getInt32LE(e,t);let E=r;const $e=t+S;if(i&&i[I]&&(E={...r,raw:!0}),g||(E={...E,validation:{utf8:T}}),y=Re(e,p,E,!0),t=t+S,e[t-1]!==0)throw new l("invalid array terminator byte");if(t!==$e)throw new l("corrupted array bson")}else if($===vt)y=void 0;else if($===Te)y=null;else if($===Ae)if(c)y=N.getBigInt64LE(e,t),t+=8;else{const p=N.getInt32LE(e,t),S=N.getInt32LE(e,t+4);t+=8;const E=new s(p,S);o&&d===!0?y=E.lessThanOrEqual(Fn)&&E.greaterThanOrEqual(Mn)?E.toNumber():E:y=E}else if($===Ge){const p=u.allocateUnsafe(16);for(let S=0;S<16;S++)p[S]=e[t+S];t=t+16,y=new D(p)}else if($===Ue){let p=N.getInt32LE(e,t);t+=4;const S=p,E=e[t++];if(p<0)throw new l("Negative binary type element size found");if(p>e.byteLength)throw new l("Binary type size larger than document size");if(e.slice!=null){if(E===_.SUBTYPE_BYTE_ARRAY){if(p=N.getInt32LE(e,t),t+=4,p<0)throw new l("Negative binary type element size found for subtype 0x02");if(p>S-4)throw new l("Binary type with subtype 0x02 contains too long binary size");if(p<S-4)throw new l("Binary type with subtype 0x02 contains too short binary size")}m&&d?y=u.toLocalBufferType(e.slice(t,t+p)):(y=new _(e.slice(t,t+p),E),E===Se&&R.isValid(y)&&(y=y.toUUID()))}else{if(E===_.SUBTYPE_BYTE_ARRAY){if(p=N.getInt32LE(e,t),t+=4,p<0)throw new l("Negative binary type element size found for subtype 0x02");if(p>S-4)throw new l("Binary type with subtype 0x02 contains too long binary size");if(p<S-4)throw new l("Binary type with subtype 0x02 contains too short binary size")}if(m&&d)for(y=u.allocateUnsafe(p),w=0;w<p;w++)y[w]=e[t+w];else y=new _(e.slice(t,t+p),E),E===Se&&R.isValid(y)&&(y=y.toUUID())}t=t+p}else if($===Be&&h===!1){for(w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new l("Bad BSON Document: illegal CString");const p=u.toUTF8(e,t,w,!1);for(t=w+1,w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new l("Bad BSON Document: illegal CString");const S=u.toUTF8(e,t,w,!1);t=w+1;const E=new Array(S.length);for(w=0;w<S.length;w++)switch(S[w]){case"m":E[w]="m";break;case"s":E[w]="g";break;case"i":E[w]="i";break}y=new RegExp(p,E.join(""))}else if($===Be&&h===!0){for(w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new l("Bad BSON Document: illegal CString");const p=u.toUTF8(e,t,w,!1);for(t=w+1,w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new l("Bad BSON Document: illegal CString");const S=u.toUTF8(e,t,w,!1);t=w+1,y=new J(p,S)}else if($===Ze){const p=N.getInt32LE(e,t);if(t+=4,p<=0||p>e.length-t||e[t+p-1]!==0)throw new l("bad string length in bson");const S=u.toUTF8(e,t,t+p-1,T);y=d?S:new ie(S),t=t+p}else if($===We)y=new H({i:N.getUint32LE(e,t),t:N.getUint32LE(e,t+4)}),t+=8;else if($===Xe)y=new se;else if($===Qe)y=new oe;else if($===ve){const p=N.getInt32LE(e,t);if(t+=4,p<=0||p>e.length-t||e[t+p-1]!==0)throw new l("bad string length in bson");const S=u.toUTF8(e,t,t+p-1,T);y=new Y(S),t=t+p}else if($===Ke){const p=N.getInt32LE(e,t);if(t+=4,p<13)throw new l("code_w_scope total size shorter minimum expected length");const S=N.getInt32LE(e,t);if(t+=4,S<=0||S>e.length-t||e[t+S-1]!==0)throw new l("bad string length in bson");const E=u.toUTF8(e,t,t+S-1,T);t=t+S;const $e=t,Q=N.getInt32LE(e,t),Kn=Re(e,$e,r,!1);if(t=t+Q,p<8+Q+S)throw new l("code_w_scope total size is too short, truncating scope");if(p>8+Q+S)throw new l("code_w_scope total size is too long, clips outer document");y=new Y(E,Kn)}else if($===At){const p=N.getInt32LE(e,t);if(t+=4,p<=0||p>e.length-t||e[t+p-1]!==0)throw new l("bad string length in bson");const S=u.toUTF8(e,t,t+p-1,T);t=t+p;const E=u.allocateUnsafe(12);for(let Q=0;Q<12;Q++)E[Q]=e[t+Q];const $e=new v(E);t=t+12,y=new k(S,$e)}else throw new l(`Detected unknown BSON type ${$.toString(16)} for fieldname "${I}"`);I==="__proto__"?Object.defineProperty(L,I,{value:y,writable:!0,enumerable:!0,configurable:!0}):L[I]=y}if(A!==t-j)throw n?new l("corrupt array bson"):new l("corrupt object bson");if(!Oe)return L;if(Jt(L)){const $=Object.assign({},L);return delete $.$ref,delete $.$id,delete $.$db,new k(L.$ref,L.$id,L.$db,$)}return L}const De=/\x00/,nn=new Set(["$db","$ref","$id","$clusterTime"]);function nt(e,t,r,n){e[n++]=Ce;const i=u.encodeUTF8Into(e,t,n);n=n+i+1,e[n-1]=0;const f=u.encodeUTF8Into(e,r,n+4);return N.setInt32LE(e,n,f+1),n=n+4+f,e[n++]=0,n}function rt(e,t,r,n){const i=!Object.is(r,-0)&&Number.isSafeInteger(r)&&r<=ce&&r>=ge?be:_e;e[n++]=i;const f=u.encodeUTF8Into(e,t,n);return n=n+f,e[n++]=0,i===be?n+=N.setInt32LE(e,n,r):n+=N.setFloat64LE(e,n,r),n}function it(e,t,r,n){e[n++]=Ae;const i=u.encodeUTF8Into(e,t,n);return n+=i,e[n++]=0,n+=N.setBigInt64LE(e,n,r),n}function ye(e,t,r,n){e[n++]=Te;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function ot(e,t,r,n){e[n++]=Pe;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,e[n++]=r?1:0,n}function st(e,t,r,n){e[n++]=Ye;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=s.fromNumber(r.getTime()),h=f.getLowBits(),m=f.getHighBits();return n+=N.setInt32LE(e,n,h),n+=N.setInt32LE(e,n,m),n}function ft(e,t,r,n){e[n++]=Be;const i=u.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.source&&r.source.match(De)!=null)throw new l("value "+r.source+" must not contain null bytes");return n=n+u.encodeUTF8Into(e,r.source,n),e[n++]=0,r.ignoreCase&&(e[n++]=105),r.global&&(e[n++]=115),r.multiline&&(e[n++]=109),e[n++]=0,n}function ut(e,t,r,n){e[n++]=Be;const i=u.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.pattern.match(De)!=null)throw new l("pattern "+r.pattern+" must not contain null bytes");n=n+u.encodeUTF8Into(e,r.pattern,n),e[n++]=0;const f=r.options.split("").sort().join("");return n=n+u.encodeUTF8Into(e,f,n),e[n++]=0,n}function at(e,t,r,n){r===null?e[n++]=Te:r._bsontype==="MinKey"?e[n++]=Xe:e[n++]=Qe;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function lt(e,t,r,n){e[n++]=ke;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=r.serializeInto(e,n),n}function ht(e,t,r,n){e[n++]=Ue;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=r.length;if(n+=N.setInt32LE(e,n,f),e[n++]=jt,f<=16)for(let h=0;h<f;h++)e[n+h]=r[h];else e.set(r,n);return n=n+f,n}function ct(e,t,r,n,i,f,h,m,o){if(o.has(r))throw new l("Cannot convert circular structure to BSON");o.add(r),e[n++]=Array.isArray(r)?qe:Le;const d=u.encodeUTF8Into(e,t,n);n=n+d,e[n++]=0;const c=Ee(e,r,i,n,f+1,h,m,o);return o.delete(r),c}function gt(e,t,r,n){e[n++]=Ge;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;for(let f=0;f<16;f++)e[n+f]=r.bytes[f];return n+16}function bt(e,t,r,n){e[n++]=r._bsontype==="Long"?Ae:We;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=r.getLowBits(),h=r.getHighBits();return n+=N.setInt32LE(e,n,f),n+=N.setInt32LE(e,n,h),n}function mt(e,t,r,n){r=r.valueOf(),e[n++]=be;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=N.setInt32LE(e,n,r),n}function dt(e,t,r,n){e[n++]=_e;const i=u.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=N.setFloat64LE(e,n,r.value),n}function pt(e,t,r,n){e[n++]=ve;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=r.toString(),h=u.encodeUTF8Into(e,f,n+4)+1;return N.setInt32LE(e,n,h),n=n+4+h-1,e[n++]=0,n}function yt(e,t,r,n,i=!1,f=0,h=!1,m=!0,o){if(r.scope&&typeof r.scope=="object"){e[n++]=Ke;const d=u.encodeUTF8Into(e,t,n);n=n+d,e[n++]=0;let c=n;const a=r.code;n=n+4;const g=u.encodeUTF8Into(e,a,n+4)+1;N.setInt32LE(e,n,g),e[n+4+g-1]=0,n=n+g+4;const B=Ee(e,r.scope,i,n,f+1,h,m,o);n=B-1;const b=B-c;c+=N.setInt32LE(e,c,b),e[n++]=0}else{e[n++]=ve;const d=u.encodeUTF8Into(e,t,n);n=n+d,e[n++]=0;const c=r.code.toString(),a=u.encodeUTF8Into(e,c,n+4)+1;N.setInt32LE(e,n,a),n=n+4+a-1,e[n++]=0}return n}function wt(e,t,r,n){e[n++]=Ue;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=r.buffer;let h=r.position;if(r.sub_type===_.SUBTYPE_BYTE_ARRAY&&(h=h+4),n+=N.setInt32LE(e,n,h),e[n++]=r.sub_type,r.sub_type===_.SUBTYPE_BYTE_ARRAY&&(h=h-4,n+=N.setInt32LE(e,n,h)),h<=16)for(let m=0;m<h;m++)e[n+m]=f[m];else e.set(f,n);return n=n+r.position,n}function Bt(e,t,r,n){e[n++]=Ze;const i=u.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const f=u.encodeUTF8Into(e,r.value,n+4)+1;return N.setInt32LE(e,n,f),n=n+4+f-1,e[n++]=0,n}function St(e,t,r,n,i,f,h){e[n++]=Le;const m=u.encodeUTF8Into(e,t,n);n=n+m,e[n++]=0;let o=n,d={$ref:r.collection||r.namespace,$id:r.oid};r.db!=null&&(d.$db=r.db),d=Object.assign(d,r.fields);const c=Ee(e,d,!1,n,i+1,f,!0,h),a=c-o;return o+=N.setInt32LE(e,n,a),c}function Ee(e,t,r,n,i,f,h,m){if(m==null){if(t==null)return e[0]=5,e[1]=0,e[2]=0,e[3]=0,e[4]=0,5;if(Array.isArray(t))throw new l("serialize does not support an array as the root input");if(typeof t!="object")throw new l("serialize does not support non-object as the root input");if("_bsontype"in t&&typeof t._bsontype=="string")throw new l("BSON types cannot be serialized as a document");if(he(t)||le(t)||ae(t)||Fe(t))throw new l("date, regexp, typedarray, and arraybuffer cannot be BSON documents");m=new Set}m.add(t);let o=n+4;if(Array.isArray(t))for(let c=0;c<t.length;c++){const a=`${c}`;let g=t[c];typeof(g==null?void 0:g.toBSON)=="function"&&(g=g.toBSON());const B=typeof g;if(g===void 0)o=ye(e,a,g,o);else if(g===null)o=ye(e,a,g,o);else if(B==="string")o=nt(e,a,g,o);else if(B==="number")o=rt(e,a,g,o);else if(B==="bigint")o=it(e,a,g,o);else if(B==="boolean")o=ot(e,a,g,o);else if(B==="object"&&g._bsontype==null)g instanceof Date||he(g)?o=st(e,a,g,o):g instanceof Uint8Array||ae(g)?o=ht(e,a,g,o):g instanceof RegExp||le(g)?o=ft(e,a,g,o):o=ct(e,a,g,o,r,i,f,h,m);else if(B==="object"){if(g[ne]!==K)throw new ee;if(g._bsontype==="ObjectId")o=lt(e,a,g,o);else if(g._bsontype==="Decimal128")o=gt(e,a,g,o);else if(g._bsontype==="Long"||g._bsontype==="Timestamp")o=bt(e,a,g,o);else if(g._bsontype==="Double")o=dt(e,a,g,o);else if(g._bsontype==="Code")o=yt(e,a,g,o,r,i,f,h,m);else if(g._bsontype==="Binary")o=wt(e,a,g,o);else if(g._bsontype==="BSONSymbol")o=Bt(e,a,g,o);else if(g._bsontype==="DBRef")o=St(e,a,g,o,i,f,m);else if(g._bsontype==="BSONRegExp")o=ut(e,a,g,o);else if(g._bsontype==="Int32")o=mt(e,a,g,o);else if(g._bsontype==="MinKey"||g._bsontype==="MaxKey")o=at(e,a,g,o);else if(typeof g._bsontype<"u")throw new l(`Unrecognized or invalid _bsontype: ${String(g._bsontype)}`)}else B==="function"&&f&&(o=pt(e,a,g,o))}else if(t instanceof Map||Me(t)){const c=t.entries();let a=!1;for(;!a;){const g=c.next();if(a=!!g.done,a)continue;const B=g.value[0];let b=g.value[1];typeof(b==null?void 0:b.toBSON)=="function"&&(b=b.toBSON());const O=typeof b;if(typeof B=="string"&&!nn.has(B)){if(B.match(De)!=null)throw new l("key "+B+" must not contain null bytes");if(r){if(B[0]==="$")throw new l("key "+B+" must not start with '$'");if(B.includes("."))throw new l("key "+B+" must not contain '.'")}}if(b===void 0)h===!1&&(o=ye(e,B,b,o));else if(b===null)o=ye(e,B,b,o);else if(O==="string")o=nt(e,B,b,o);else if(O==="number")o=rt(e,B,b,o);else if(O==="bigint")o=it(e,B,b,o);else if(O==="boolean")o=ot(e,B,b,o);else if(O==="object"&&b._bsontype==null)b instanceof Date||he(b)?o=st(e,B,b,o):b instanceof Uint8Array||ae(b)?o=ht(e,B,b,o):b instanceof RegExp||le(b)?o=ft(e,B,b,o):o=ct(e,B,b,o,r,i,f,h,m);else if(O==="object"){if(b[ne]!==K)throw new ee;if(b._bsontype==="ObjectId")o=lt(e,B,b,o);else if(b._bsontype==="Decimal128")o=gt(e,B,b,o);else if(b._bsontype==="Long"||b._bsontype==="Timestamp")o=bt(e,B,b,o);else if(b._bsontype==="Double")o=dt(e,B,b,o);else if(b._bsontype==="Code")o=yt(e,B,b,o,r,i,f,h,m);else if(b._bsontype==="Binary")o=wt(e,B,b,o);else if(b._bsontype==="BSONSymbol")o=Bt(e,B,b,o);else if(b._bsontype==="DBRef")o=St(e,B,b,o,i,f,m);else if(b._bsontype==="BSONRegExp")o=ut(e,B,b,o);else if(b._bsontype==="Int32")o=mt(e,B,b,o);else if(b._bsontype==="MinKey"||b._bsontype==="MaxKey")o=at(e,B,b,o);else if(typeof b._bsontype<"u")throw new l(`Unrecognized or invalid _bsontype: ${String(b._bsontype)}`)}else O==="function"&&f&&(o=pt(e,B,b,o))}}else{if(typeof(t==null?void 0:t.toBSON)=="function"&&(t=t.toBSON(),t!=null&&typeof t!="object"))throw new l("toBSON function did not return an object");for(const c of Object.keys(t)){let a=t[c];typeof(a==null?void 0:a.toBSON)=="function"&&(a=a.toBSON());const g=typeof a;if(typeof c=="string"&&!nn.has(c)){if(c.match(De)!=null)throw new l("key "+c+" must not contain null bytes");if(r){if(c[0]==="$")throw new l("key "+c+" must not start with '$'");if(c.includes("."))throw new l("key "+c+" must not contain '.'")}}if(a===void 0)h===!1&&(o=ye(e,c,a,o));else if(a===null)o=ye(e,c,a,o);else if(g==="string")o=nt(e,c,a,o);else if(g==="number")o=rt(e,c,a,o);else if(g==="bigint")o=it(e,c,a,o);else if(g==="boolean")o=ot(e,c,a,o);else if(g==="object"&&a._bsontype==null)a instanceof Date||he(a)?o=st(e,c,a,o):a instanceof Uint8Array||ae(a)?o=ht(e,c,a,o):a instanceof RegExp||le(a)?o=ft(e,c,a,o):o=ct(e,c,a,o,r,i,f,h,m);else if(g==="object"){if(a[ne]!==K)throw new ee;if(a._bsontype==="ObjectId")o=lt(e,c,a,o);else if(a._bsontype==="Decimal128")o=gt(e,c,a,o);else if(a._bsontype==="Long"||a._bsontype==="Timestamp")o=bt(e,c,a,o);else if(a._bsontype==="Double")o=dt(e,c,a,o);else if(a._bsontype==="Code")o=yt(e,c,a,o,r,i,f,h,m);else if(a._bsontype==="Binary")o=wt(e,c,a,o);else if(a._bsontype==="BSONSymbol")o=Bt(e,c,a,o);else if(a._bsontype==="DBRef")o=St(e,c,a,o,i,f,m);else if(a._bsontype==="BSONRegExp")o=ut(e,c,a,o);else if(a._bsontype==="Int32")o=mt(e,c,a,o);else if(a._bsontype==="MinKey"||a._bsontype==="MaxKey")o=at(e,c,a,o);else if(typeof a._bsontype<"u")throw new l(`Unrecognized or invalid _bsontype: ${String(a._bsontype)}`)}else g==="function"&&f&&(o=pt(e,c,a,o))}}m.delete(t),e[o++]=0;const d=o-n;return n+=N.setInt32LE(e,n,d),o}function Jn(e){return e!=null&&typeof e=="object"&&"_bsontype"in e&&typeof e._bsontype=="string"}const Vn={$oid:v,$binary:_,$uuid:_,$symbol:ie,$numberInt:Z,$numberDecimal:D,$numberDouble:V,$numberLong:s,$minKey:se,$maxKey:oe,$regex:J,$regularExpression:J,$timestamp:H};function rn(e,t={}){if(typeof e=="number"){const n=e<=ce&&e>=ge,i=e<=ze&&e>=Je;if(t.relaxed||t.legacy)return e;if(Number.isInteger(e)&&!Object.is(e,-0)){if(n)return new Z(e);if(i)return t.useBigInt64?BigInt(e):s.fromNumber(e)}return new V(e)}if(e==null||typeof e!="object")return e;if(e.$undefined)return null;const r=Object.keys(e).filter(n=>n.startsWith("$")&&e[n]!=null);for(let n=0;n<r.length;n++){const i=Vn[r[n]];if(i)return i.fromExtendedJSON(e,t)}if(e.$date!=null){const n=e.$date,i=new Date;if(t.legacy)if(typeof n=="number")i.setTime(n);else if(typeof n=="string")i.setTime(Date.parse(n));else if(typeof n=="bigint")i.setTime(Number(n));else throw new Ie(`Unrecognized type for EJSON date: ${typeof n}`);else if(typeof n=="string")i.setTime(Date.parse(n));else if(s.isLong(n))i.setTime(n.toNumber());else if(typeof n=="number"&&t.relaxed)i.setTime(n);else if(typeof n=="bigint")i.setTime(Number(n));else throw new Ie(`Unrecognized type for EJSON date: ${typeof n}`);return i}if(e.$code!=null){const n=Object.assign({},e);return e.$scope&&(n.$scope=rn(e.$scope)),Y.fromExtendedJSON(e)}if(Jt(e)||e.$dbPointer){const n=e.$ref?e:e.$dbPointer;if(n instanceof k)return n;const i=Object.keys(n).filter(h=>h.startsWith("$"));let f=!0;if(i.forEach(h=>{["$ref","$id","$db"].indexOf(h)===-1&&(f=!1)}),f)return k.fromExtendedJSON(n)}return e}function Hn(e,t){return e.map((r,n)=>{t.seenObjects.push({propertyName:`index ${n}`,obj:null});try{return P(r,t)}finally{t.seenObjects.pop()}})}function on(e){const t=e.toISOString();return e.getUTCMilliseconds()!==0?t:t.slice(0,-5)+"Z"}function P(e,t){if(e instanceof Map||Me(e)){const r=Object.create(null);for(const[n,i]of e){if(typeof n!="string")throw new l("Can only serialize maps with string keys");r[n]=i}return P(r,t)}if((typeof e=="object"||typeof e=="function")&&e!==null){const r=t.seenObjects.findIndex(n=>n.obj===e);if(r!==-1){const n=t.seenObjects.map(c=>c.propertyName),i=n.slice(0,r).map(c=>`${c} -> `).join(""),f=n[r],h=" -> "+n.slice(r+1,n.length-1).map(c=>`${c} -> `).join(""),m=n[n.length-1],o=" ".repeat(i.length+f.length/2),d="-".repeat(h.length+(f.length+m.length)/2-1);throw new l(`Converting circular structure to EJSON:
    ${i}${f}${h}${m}
    ${o}\\${d}/`)}t.seenObjects[t.seenObjects.length-1].obj=e}if(Array.isArray(e))return Hn(e,t);if(e===void 0)return null;if(e instanceof Date||he(e)){const r=e.getTime(),n=r>-1&&r<2534023188e5;return t.legacy?t.relaxed&&n?{$date:e.getTime()}:{$date:on(e)}:t.relaxed&&n?{$date:on(e)}:{$date:{$numberLong:e.getTime().toString()}}}if(typeof e=="number"&&(!t.relaxed||!isFinite(e))){if(Number.isInteger(e)&&!Object.is(e,-0)){if(e>=ge&&e<=ce)return{$numberInt:e.toString()};if(e>=Je&&e<=ze)return{$numberLong:e.toString()}}return{$numberDouble:Object.is(e,-0)?"-0.0":e.toString()}}if(typeof e=="bigint")return t.relaxed?Number(BigInt.asIntN(64,e)):{$numberLong:BigInt.asIntN(64,e).toString()};if(e instanceof RegExp||le(e)){let r=e.flags;if(r===void 0){const n=e.toString().match(/[gimuy]*$/);n&&(r=n[0])}return new J(e.source,r).toExtendedJSON(t)}return e!=null&&typeof e=="object"?qn(e,t):e}const Cn={Binary:e=>new _(e.value(),e.sub_type),Code:e=>new Y(e.code,e.scope),DBRef:e=>new k(e.collection||e.namespace,e.oid,e.db,e.fields),Decimal128:e=>new D(e.bytes),Double:e=>new V(e.value),Int32:e=>new Z(e.value),Long:e=>s.fromBits(e.low!=null?e.low:e.low_,e.low!=null?e.high:e.high_,e.low!=null?e.unsigned:e.unsigned_),MaxKey:()=>new oe,MinKey:()=>new se,ObjectId:e=>new v(e),BSONRegExp:e=>new J(e.pattern,e.options),BSONSymbol:e=>new ie(e.value),Timestamp:e=>H.fromBits(e.low,e.high)};function qn(e,t){if(e==null||typeof e!="object")throw new l("not an object instance");const r=e._bsontype;if(typeof r>"u"){const n={};for(const i of Object.keys(e)){t.seenObjects.push({propertyName:i,obj:null});try{const f=P(e[i],t);i==="__proto__"?Object.defineProperty(n,i,{value:f,writable:!0,enumerable:!0,configurable:!0}):n[i]=f}finally{t.seenObjects.pop()}}return n}else{if(e!=null&&typeof e=="object"&&typeof e._bsontype=="string"&&e[ne]!==K)throw new ee;if(Jn(e)){let n=e;if(typeof n.toExtendedJSON!="function"){const i=Cn[e._bsontype];if(!i)throw new l("Unrecognized or invalid _bsontype: "+e._bsontype);n=i(n)}return r==="Code"&&n.scope?n=new Y(n.code,P(n.scope,t)):r==="DBRef"&&n.oid&&(n=new k(P(n.collection,t),P(n.oid,t),P(n.db,t),P(n.fields,t))),n.toExtendedJSON(t)}else throw new l("_bsontype must be a string, but was: "+typeof r)}}function sn(e,t){const r={useBigInt64:(t==null?void 0:t.useBigInt64)??!1,relaxed:(t==null?void 0:t.relaxed)??!0,legacy:(t==null?void 0:t.legacy)??!1};return JSON.parse(e,(n,i)=>{if(n.indexOf("\0")!==-1)throw new l(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(n)}`);return rn(i,r)})}function fn(e,t,r,n){r!=null&&typeof r=="object"&&(n=r,r=0),t!=null&&typeof t=="object"&&!Array.isArray(t)&&(n=t,t=void 0,r=0);const i=Object.assign({relaxed:!0,legacy:!1},n,{seenObjects:[{propertyName:"(root)",obj:null}]}),f=P(e,i);return JSON.stringify(f,t,r)}function kn(e,t){return t=t||{},JSON.parse(fn(e,t))}function Pn(e,t){return t=t||{},sn(JSON.stringify(e),t)}te=Object.create(null),te.parse=sn,te.stringify=fn,te.serialize=kn,te.deserialize=Pn,Object.freeze(te);function Nt(e,t){try{return N.getNonnegativeInt32LE(e,t)}catch(r){throw new q("BSON size cannot be negative",t,{cause:r})}}function xt(e,t){let r=t;for(;e[r]!==0;r++);if(r===e.length-1)throw new q("Null terminator not found",t);return r}function Yn(e,t=0){if(t??(t=0),e.length<5)throw new q(`Input must be at least 5 bytes, got ${e.length} bytes`,t);const r=Nt(e,t);if(r>e.length-t)throw new q(`Parsed documentSize (${r} bytes) does not match input length (${e.length} bytes)`,t);if(e[t+r-1]!==0)throw new q("BSON documents must end in 0x00",t+r);const n=[];let i=t+4;for(;i<=r+t;){const f=e[i];if(i+=1,f===0){if(i-t!==r)throw new q("Invalid 0x00 type byte",i);break}const h=i,m=xt(e,i)-h;i+=m+1;let o;if(f===1||f===18||f===9||f===17)o=8;else if(f===16)o=4;else if(f===7)o=12;else if(f===19)o=16;else if(f===8)o=1;else if(f===10||f===6||f===127||f===255)o=0;else if(f===11)o=xt(e,xt(e,i)+1)+1-i;else if(f===3||f===4||f===15)o=Nt(e,i);else if(f===2||f===5||f===12||f===13||f===14)o=Nt(e,i)+4,f===5&&(o+=1),f===12&&(o+=12);else throw new q(`Invalid 0x${f.toString(16).padStart(2,"0")} type byte`,i);if(o>r)throw new q("value reports length larger than document",i);n.push([f,h,m,i,o]),i+=o}return n}fe=Object.create(null),fe.parseToElements=Yn,fe.ByteUtils=u,fe.NumberUtils=N,Object.freeze(fe);const un=1024*1024*17;let G=u.allocate(un);Ut=function(e){G.length<e&&(G=u.allocate(e))},_t=function(e,t={}){const r=typeof t.checkKeys=="boolean"?t.checkKeys:!1,n=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,i=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0,f=typeof t.minInternalBufferSize=="number"?t.minInternalBufferSize:un;G.length<f&&(G=u.allocate(f));const h=Ee(G,e,r,0,0,n,i,null),m=u.allocateUnsafe(h);return m.set(G.subarray(0,h),0),m},Lt=function(e,t,r={}){const n=typeof r.checkKeys=="boolean"?r.checkKeys:!1,i=typeof r.serializeFunctions=="boolean"?r.serializeFunctions:!1,f=typeof r.ignoreUndefined=="boolean"?r.ignoreUndefined:!0,h=typeof r.index=="number"?r.index:0,m=Ee(G,e,n,0,0,i,f,null);return t.set(G.subarray(0,m),h),h+m-1},$t=function(e,t={}){return tn(u.toLocalBufferType(e),t)},Ot=function(e,t={}){t=t||{};const r=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,n=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0;return je(e,r,n)},It=function(e,t,r,n,i,f){const h=Object.assign({allowObjectSmallerThanBufferSize:!0,index:0},f),m=u.toLocalBufferType(e);let o=t;for(let d=0;d<r;d++){const c=N.getInt32LE(m,o);h.index=o,n[i+d]=tn(m,h),o=o+c}return o},ln=Object.freeze({__proto__:null,BSONError:l,BSONOffsetError:q,BSONRegExp:J,BSONRuntimeError:Ie,BSONSymbol:ie,BSONType:Et,BSONValue:F,BSONVersionError:ee,Binary:_,Code:Y,DBRef:k,Decimal128:D,Double:V,EJSON:te,Int32:Z,Long:s,MaxKey:oe,MinKey:se,ObjectId:v,Timestamp:H,UUID:R,calculateObjectSize:Ot,deserialize:$t,deserializeStream:It,onDemand:fe,serialize:_t,serializeWithBufferAndIndex:Lt,setInternalBufferSize:Ut});const Zn=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}))});export{ln as BSON,l as BSONError,q as BSONOffsetError,J as BSONRegExp,Ie as BSONRuntimeError,ie as BSONSymbol,Et as BSONType,F as BSONValue,ee as BSONVersionError,_ as Binary,Y as Code,k as DBRef,D as Decimal128,V as Double,te as EJSON,Z as Int32,s as Long,oe as MaxKey,se as MinKey,v as ObjectId,H as Timestamp,R as UUID,Xn as __tla,Ot as calculateObjectSize,$t as deserialize,It as deserializeStream,fe as onDemand,_t as serialize,Lt as serializeWithBufferAndIndex,Ut as setInternalBufferSize};
