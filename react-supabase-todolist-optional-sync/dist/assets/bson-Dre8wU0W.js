let qn,c,Z,k,te,mt,rn,P,ut,A,v,K,j,W,wt,tt,f,gt,yt,L,Y,F,Yn,Wn,kn,It,Hn,Vn,Jn;let __tla=(async()=>{const he=new WeakMap,at={ArrayBuffer:"[object ArrayBuffer]",SharedArrayBuffer:"[object SharedArrayBuffer]",Uint8Array:"[object Uint8Array]",RegExp:"[object RegExp]",Map:"[object Map]",Date:"[object Date]"};function Nt(e){let t=he.get(e);return t||(t=Object.prototype.toString.call(e),e!==null&&typeof e=="object"&&he.set(e,t)),t}function ee(e){const t=Nt(e);return t===at.ArrayBuffer||t===at.SharedArrayBuffer}function st(e){return Nt(e)===at.Uint8Array}function ot(e){return Nt(e)===at.RegExp}function ne(e){return Nt(e)===at.Map}function ft(e){return Nt(e)===at.Date}function C(e,t){return JSON.stringify(e,(r,n)=>typeof n=="bigint"?{$numberLong:`${n}`}:ne(n)?Object.fromEntries(n):n)}function ve(e){if(e!=null&&typeof e=="object"&&"stylize"in e&&typeof e.stylize=="function")return e.stylize}let nt,ct,Bt,Et,$e,Ae,_e,Ue,re,Re,ie,Le,se,tn,De,ze,Me,oe,$t,en,fe,xe,Fe,bt,je,le,Ce,Pe,Je,nn,At;nt=6;ct=Symbol.for("@@mdb.bson.version");Bt=0x7fffffff;Et=-0x80000000;$e=Math.pow(2,63)-1;Ae=-Math.pow(2,63);_e=Math.pow(2,53);Ue=-Math.pow(2,53);re=1;Re=2;ie=3;Le=4;se=5;tn=6;De=7;ze=8;Me=9;oe=10;$t=11;en=12;fe=13;xe=14;Fe=15;bt=16;je=17;le=18;Ce=19;Pe=255;Je=127;nn=0;At=4;rn=Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127});c=class extends Error{get bsonError(){return!0}get name(){return"BSONError"}constructor(t,r){super(t,r)}static isBSONError(t){return t!=null&&typeof t=="object"&&"bsonError"in t&&t.bsonError===!0&&"name"in t&&"message"in t&&"stack"in t}};ut=class extends c{get name(){return"BSONVersionError"}constructor(){super(`Unsupported BSON version, bson types must be from bson ${nt}.x.x`)}};te=class extends c{get name(){return"BSONRuntimeError"}constructor(t){super(t)}};Z=class extends c{get name(){return"BSONOffsetError"}constructor(t,r,n){super(`${t}. offset: ${r}`,n),this.offset=r}};let ce,ue;function He(e,t,r,n){if(n){ce??=new TextDecoder("utf8",{fatal:!0});try{return ce.decode(e.subarray(t,r))}catch(i){throw new c("Invalid UTF-8 string in BSON document",{cause:i})}}return ue??=new TextDecoder("utf8",{fatal:!1}),ue.decode(e.subarray(t,r))}function Ve(e,t,r){if(e.length===0)return"";const n=r-t;if(n===0)return"";if(n>20)return null;if(n===1&&e[t]<128)return String.fromCharCode(e[t]);if(n===2&&e[t]<128&&e[t+1]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1]);if(n===3&&e[t]<128&&e[t+1]<128&&e[t+2]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1])+String.fromCharCode(e[t+2]);const i=[];for(let o=t;o<r;o++){const u=e[o];if(u>127)return null;i.push(u)}return String.fromCharCode(...i)}function sn(e,t,r){if(t.length===0)return 0;if(t.length>25||e.length-r<t.length)return null;for(let n=0,i=r;n<t.length;n++,i++){const o=t.charCodeAt(n);if(o>127)return null;e[i]=o}return t.length}function on(e){return X.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const fn=await (async()=>{try{return(await Promise.resolve().then(function(){return Zn})).randomBytes}catch{return on}})(),X={toLocalBufferType(e){if(Buffer.isBuffer(e))return e;if(ArrayBuffer.isView(e))return Buffer.from(e.buffer,e.byteOffset,e.byteLength);const t=e?.[Symbol.toStringTag]??Object.prototype.toString.call(e);if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return Buffer.from(e);throw new c(`Cannot create Buffer from ${String(e)}`)},allocate(e){return Buffer.alloc(e)},allocateUnsafe(e){return Buffer.allocUnsafe(e)},equals(e,t){return X.toLocalBufferType(e).equals(t)},fromNumberArray(e){return Buffer.from(e)},fromBase64(e){return Buffer.from(e,"base64")},toBase64(e){return X.toLocalBufferType(e).toString("base64")},fromISO88591(e){return Buffer.from(e,"binary")},toISO88591(e){return X.toLocalBufferType(e).toString("binary")},fromHex(e){return Buffer.from(e,"hex")},toHex(e){return X.toLocalBufferType(e).toString("hex")},toUTF8(e,t,r,n){const i=r-t<=20?Ve(e,t,r):null;if(i!=null)return i;const o=X.toLocalBufferType(e).toString("utf8",t,r);if(n){for(let u=0;u<o.length;u++)if(o.charCodeAt(u)===65533){He(e,t,r,!0);break}}return o},utf8ByteLength(e){return Buffer.byteLength(e,"utf8")},encodeUTF8Into(e,t,r){const n=sn(e,t,r);return n??X.toLocalBufferType(e).write(t,r,void 0,"utf8")},randomBytes:fn};function ln(){const{navigator:e}=globalThis;return typeof e=="object"&&e.product==="ReactNative"}function hn(e){if(e<0)throw new RangeError(`The argument 'byteLength' is invalid. Received ${e}`);return St.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const cn=(()=>{const{crypto:e}=globalThis;if(e!=null&&typeof e.getRandomValues=="function")return t=>e.getRandomValues(St.allocate(t));if(ln()){const{console:t}=globalThis;t?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return hn})(),ae=/(\d|[a-f])/i,St={toLocalBufferType(e){const t=e?.[Symbol.toStringTag]??Object.prototype.toString.call(e);if(t==="Uint8Array")return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength));if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return new Uint8Array(e);throw new c(`Cannot make a Uint8Array from ${String(e)}`)},allocate(e){if(typeof e!="number")throw new TypeError(`The "size" argument must be of type number. Received ${String(e)}`);return new Uint8Array(e)},allocateUnsafe(e){return St.allocate(e)},equals(e,t){if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0},fromNumberArray(e){return Uint8Array.from(e)},fromBase64(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))},toBase64(e){return btoa(St.toISO88591(e))},fromISO88591(e){return Uint8Array.from(e,t=>t.charCodeAt(0)&255)},toISO88591(e){return Array.from(Uint16Array.from(e),t=>String.fromCharCode(t)).join("")},fromHex(e){const t=e.length%2===0?e:e.slice(0,e.length-1),r=[];for(let n=0;n<t.length;n+=2){const i=t[n],o=t[n+1];if(!ae.test(i)||!ae.test(o))break;const u=Number.parseInt(`${i}${o}`,16);r.push(u)}return Uint8Array.from(r)},toHex(e){return Array.from(e,t=>t.toString(16).padStart(2,"0")).join("")},toUTF8(e,t,r,n){const i=r-t<=20?Ve(e,t,r):null;return i??He(e,t,r,n)},utf8ByteLength(e){return new TextEncoder().encode(e).byteLength},encodeUTF8Into(e,t,r){const n=new TextEncoder().encode(t);return e.set(n,r),n.byteLength},randomBytes:cn},un=typeof Buffer=="function"&&Buffer.prototype?._isBuffer!==!0,h=un?X:St;P=class{get[ct](){return nt}[Symbol.for("nodejs.util.inspect.custom")](t,r,n){return this.inspect(t,r,n)}};A=class extends P{get _bsontype(){return"Binary"}constructor(t,r){if(super(),t!=null&&typeof t=="string"&&!ArrayBuffer.isView(t)&&!ee(t)&&!Array.isArray(t))throw new c("Binary can only be constructed from Uint8Array or number[]");this.sub_type=r??A.BSON_BINARY_SUBTYPE_DEFAULT,t==null?(this.buffer=h.allocate(A.BUFFER_SIZE),this.position=0):(this.buffer=Array.isArray(t)?h.fromNumberArray(t):h.toLocalBufferType(t),this.position=this.buffer.byteLength)}put(t){if(typeof t=="string"&&t.length!==1)throw new c("only accepts single character String");if(typeof t!="number"&&t.length!==1)throw new c("only accepts single character Uint8Array or Array");let r;if(typeof t=="string"?r=t.charCodeAt(0):typeof t=="number"?r=t:r=t[0],r<0||r>255)throw new c("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.byteLength>this.position)this.buffer[this.position++]=r;else{const n=h.allocate(A.BUFFER_SIZE+this.buffer.length);n.set(this.buffer,0),this.buffer=n,this.buffer[this.position++]=r}}write(t,r){if(r=typeof r=="number"?r:this.position,this.buffer.byteLength<r+t.length){const n=h.allocate(this.buffer.byteLength+t.length);n.set(this.buffer,0),this.buffer=n}if(ArrayBuffer.isView(t))this.buffer.set(h.toLocalBufferType(t),r),this.position=r+t.byteLength>this.position?r+t.length:this.position;else if(typeof t=="string")throw new c("input cannot be string")}read(t,r){return r=r&&r>0?r:this.position,this.buffer.slice(t,t+r)}value(){return this.buffer.length===this.position?this.buffer:this.buffer.subarray(0,this.position)}length(){return this.position}toJSON(){return h.toBase64(this.buffer.subarray(0,this.position))}toString(t){return t==="hex"?h.toHex(this.buffer.subarray(0,this.position)):t==="base64"?h.toBase64(this.buffer.subarray(0,this.position)):t==="utf8"||t==="utf-8"?h.toUTF8(this.buffer,0,this.position,!1):h.toUTF8(this.buffer,0,this.position,!1)}toExtendedJSON(t){t=t||{};const r=h.toBase64(this.buffer),n=Number(this.sub_type).toString(16);return t.legacy?{$binary:r,$type:n.length===1?"0"+n:n}:{$binary:{base64:r,subType:n.length===1?"0"+n:n}}}toUUID(){if(this.sub_type===A.SUBTYPE_UUID)return new F(this.buffer.slice(0,this.position));throw new c(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${A.SUBTYPE_UUID}" is currently supported.`)}static createFromHexString(t,r){return new A(h.fromHex(t),r)}static createFromBase64(t,r){return new A(h.fromBase64(t),r)}static fromExtendedJSON(t,r){r=r||{};let n,i;if("$binary"in t?r.legacy&&typeof t.$binary=="string"&&"$type"in t?(i=t.$type?parseInt(t.$type,16):0,n=h.fromBase64(t.$binary)):typeof t.$binary!="string"&&(i=t.$binary.subType?parseInt(t.$binary.subType,16):0,n=h.fromBase64(t.$binary.base64)):"$uuid"in t&&(i=4,n=F.bytesFromString(t.$uuid)),!n)throw new c(`Unexpected Binary Extended JSON format ${JSON.stringify(t)}`);return i===At?new F(n):new A(n,i)}inspect(t,r,n){n??=C;const i=h.toBase64(this.buffer.subarray(0,this.position)),o=n(i,r),u=n(this.sub_type,r);return`Binary.createFromBase64(${o}, ${u})`}};A.BSON_BINARY_SUBTYPE_DEFAULT=0;A.BUFFER_SIZE=256;A.SUBTYPE_DEFAULT=0;A.SUBTYPE_FUNCTION=1;A.SUBTYPE_BYTE_ARRAY=2;A.SUBTYPE_UUID_OLD=3;A.SUBTYPE_UUID=4;A.SUBTYPE_MD5=5;A.SUBTYPE_ENCRYPTED=6;A.SUBTYPE_COLUMN=7;A.SUBTYPE_SENSITIVE=8;A.SUBTYPE_USER_DEFINED=128;const Ut=16,an=/^[0-9A-F]{32}$/i,gn=/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;F=class extends A{constructor(t){let r;if(t==null)r=F.generate();else if(t instanceof F)r=h.toLocalBufferType(new Uint8Array(t.buffer));else if(ArrayBuffer.isView(t)&&t.byteLength===Ut)r=h.toLocalBufferType(t);else if(typeof t=="string")r=F.bytesFromString(t);else throw new c("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");super(r,At)}get id(){return this.buffer}set id(t){this.buffer=t}toHexString(t=!0){return t?[h.toHex(this.buffer.subarray(0,4)),h.toHex(this.buffer.subarray(4,6)),h.toHex(this.buffer.subarray(6,8)),h.toHex(this.buffer.subarray(8,10)),h.toHex(this.buffer.subarray(10,16))].join("-"):h.toHex(this.buffer)}toString(t){return t==="hex"?h.toHex(this.id):t==="base64"?h.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}equals(t){if(!t)return!1;if(t instanceof F)return h.equals(t.id,this.id);try{return h.equals(new F(t).id,this.id)}catch{return!1}}toBinary(){return new A(this.id,A.SUBTYPE_UUID)}static generate(){const t=h.randomBytes(Ut);return t[6]=t[6]&15|64,t[8]=t[8]&63|128,t}static isValid(t){return t?typeof t=="string"?F.isValidUUIDString(t):st(t)?t.byteLength===Ut:t._bsontype==="Binary"&&t.sub_type===this.SUBTYPE_UUID&&t.buffer.byteLength===16:!1}static createFromHexString(t){const r=F.bytesFromString(t);return new F(r)}static createFromBase64(t){return new F(h.fromBase64(t))}static bytesFromString(t){if(!F.isValidUUIDString(t))throw new c("UUID string representation must be 32 hex digits or canonical hyphenated representation");return h.fromHex(t.replace(/-/g,""))}static isValidUUIDString(t){return an.test(t)||gn.test(t)}inspect(t,r,n){return n??=C,`new UUID(${n(this.toHexString(),r)})`}};v=class extends P{get _bsontype(){return"Code"}constructor(t,r){super(),this.code=t.toString(),this.scope=r??null}toJSON(){return this.scope!=null?{code:this.code,scope:this.scope}:{code:this.code}}toExtendedJSON(){return this.scope?{$code:this.code,$scope:this.scope}:{$code:this.code}}static fromExtendedJSON(t){return new v(t.$code,t.$scope)}inspect(t,r,n){n??=C;let i=n(this.code,r);const o=i.includes(`
`);this.scope!=null&&(i+=`,${o?`
`:" "}${n(this.scope,r)}`);const u=o&&this.scope===null;return`new Code(${o?`
`:""}${i}${u?`
`:""})`}};function We(e){return e!=null&&typeof e=="object"&&"$id"in e&&e.$id!=null&&"$ref"in e&&typeof e.$ref=="string"&&(!("$db"in e)||"$db"in e&&typeof e.$db=="string")}K=class extends P{get _bsontype(){return"DBRef"}constructor(t,r,n,i){super();const o=t.split(".");o.length===2&&(n=o.shift(),t=o.shift()),this.collection=t,this.oid=r,this.db=n,this.fields=i||{}}get namespace(){return this.collection}set namespace(t){this.collection=t}toJSON(){const t=Object.assign({$ref:this.collection,$id:this.oid},this.fields);return this.db!=null&&(t.$db=this.db),t}toExtendedJSON(t){t=t||{};let r={$ref:this.collection,$id:this.oid};return t.legacy||(this.db&&(r.$db=this.db),r=Object.assign(r,this.fields)),r}static fromExtendedJSON(t){const r=Object.assign({},t);return delete r.$ref,delete r.$id,delete r.$db,new K(t.$ref,t.$id,t.$db,r)}inspect(t,r,n){n??=C;const i=[n(this.namespace,r),n(this.oid,r),...this.db?[n(this.db,r)]:[],...Object.keys(this.fields).length>0?[n(this.fields,r)]:[]];return i[1]=n===C?`new ObjectId(${i[1]})`:i[1],`new DBRef(${i.join(", ")})`}};function Ye(e){if(e==="")return e;let t=0;const r=e[t]==="-",n=e[t]==="+";(n||r)&&(t+=1);let i=!1;for(;t<e.length&&e[t]==="0";++t)i=!0;return i?`${r?"-":""}${e.length===t?"0":e.slice(t)}`:n?e.slice(1):e}function yn(e,t){t=t??10;const r="0123456789abcdefghijklmnopqrstuvwxyz".slice(0,t);return new RegExp(`[^-+${r}]`,"i").test(e)?!1:e}let J;try{J=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}const ge=65536,mn=1<<24,lt=ge*ge,ke=lt*lt,ye=ke/2,me={},we={},wn=20,pn=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;f=class extends P{get _bsontype(){return"Long"}get __isLong__(){return!0}constructor(t=0,r,n){super();const i=typeof r=="boolean"?r:!!n,o=typeof r=="number"?r:0,u=typeof t=="string"?f.fromString(t,i):typeof t=="bigint"?f.fromBigInt(t,i):{low:t|0,high:o|0,unsigned:i};this.low=u.low,this.high=u.high,this.unsigned=u.unsigned}static fromBits(t,r,n){return new f(t,r,n)}static fromInt(t,r){let n,i,o;return r?(t>>>=0,(o=0<=t&&t<256)&&(i=we[t],i)?i:(n=f.fromBits(t,(t|0)<0?-1:0,!0),o&&(we[t]=n),n)):(t|=0,(o=-128<=t&&t<128)&&(i=me[t],i)?i:(n=f.fromBits(t,t<0?-1:0,!1),o&&(me[t]=n),n))}static fromNumber(t,r){if(isNaN(t))return r?f.UZERO:f.ZERO;if(r){if(t<0)return f.UZERO;if(t>=ke)return f.MAX_UNSIGNED_VALUE}else{if(t<=-ye)return f.MIN_VALUE;if(t+1>=ye)return f.MAX_VALUE}return t<0?f.fromNumber(-t,r).neg():f.fromBits(t%lt|0,t/lt|0,r)}static fromBigInt(t,r){const n=BigInt(0xffffffff),i=BigInt(32);return new f(Number(t&n),Number(t>>i&n),r)}static _fromString(t,r,n){if(t.length===0)throw new c("empty string");if(n<2||36<n)throw new c("radix");let i;if((i=t.indexOf("-"))>0)throw new c("interior hyphen");if(i===0)return f._fromString(t.substring(1),r,n).neg();const o=f.fromNumber(Math.pow(n,8));let u=f.ZERO;for(let g=0;g<t.length;g+=8){const s=Math.min(8,t.length-g),S=parseInt(t.substring(g,g+s),n);if(s<8){const y=f.fromNumber(Math.pow(n,s));u=u.mul(y).add(f.fromNumber(S))}else u=u.mul(o),u=u.add(f.fromNumber(S))}return u.unsigned=r,u}static fromStringStrict(t,r,n){let i=!1;if(typeof r=="number"?(n=r,r=!1):i=!!r,n??=10,t.trim()!==t)throw new c(`Input: '${t}' contains leading and/or trailing whitespace`);if(!yn(t,n))throw new c(`Input: '${t}' contains invalid characters for radix: ${n}`);const o=Ye(t),u=f._fromString(o,i,n);if(u.toString(n).toLowerCase()!==o.toLowerCase())throw new c(`Input: ${t} is not representable as ${u.unsigned?"an unsigned":"a signed"} 64-bit Long ${n!=null?`with radix: ${n}`:""}`);return u}static fromString(t,r,n){let i=!1;return typeof r=="number"?(n=r,r=!1):i=!!r,n??=10,t==="NaN"&&n<24||(t==="Infinity"||t==="+Infinity"||t==="-Infinity")&&n<35?f.ZERO:f._fromString(t,i,n)}static fromBytes(t,r,n){return n?f.fromBytesLE(t,r):f.fromBytesBE(t,r)}static fromBytesLE(t,r){return new f(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,r)}static fromBytesBE(t,r){return new f(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],r)}static isLong(t){return t!=null&&typeof t=="object"&&"__isLong__"in t&&t.__isLong__===!0}static fromValue(t,r){return typeof t=="number"?f.fromNumber(t,r):typeof t=="string"?f.fromString(t,r):f.fromBits(t.low,t.high,typeof r=="boolean"?r:t.unsigned)}add(t){f.isLong(t)||(t=f.fromValue(t));const r=this.high>>>16,n=this.high&65535,i=this.low>>>16,o=this.low&65535,u=t.high>>>16,g=t.high&65535,s=t.low>>>16,S=t.low&65535;let y=0,l=0,a=0,w=0;return w+=o+S,a+=w>>>16,w&=65535,a+=i+s,l+=a>>>16,a&=65535,l+=n+g,y+=l>>>16,l&=65535,y+=r+u,y&=65535,f.fromBits(a<<16|w,y<<16|l,this.unsigned)}and(t){return f.isLong(t)||(t=f.fromValue(t)),f.fromBits(this.low&t.low,this.high&t.high,this.unsigned)}compare(t){if(f.isLong(t)||(t=f.fromValue(t)),this.eq(t))return 0;const r=this.isNegative(),n=t.isNegative();return r&&!n?-1:!r&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1}comp(t){return this.compare(t)}divide(t){if(f.isLong(t)||(t=f.fromValue(t)),t.isZero())throw new c("division by zero");if(J){if(!this.unsigned&&this.high===-0x80000000&&t.low===-1&&t.high===-1)return this;const o=(this.unsigned?J.div_u:J.div_s)(this.low,this.high,t.low,t.high);return f.fromBits(o,J.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?f.UZERO:f.ZERO;let r,n,i;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return f.UZERO;if(t.gt(this.shru(1)))return f.UONE;i=f.UZERO}else{if(this.eq(f.MIN_VALUE))return t.eq(f.ONE)||t.eq(f.NEG_ONE)?f.MIN_VALUE:t.eq(f.MIN_VALUE)?f.ONE:(r=this.shr(1).div(t).shl(1),r.eq(f.ZERO)?t.isNegative()?f.ONE:f.NEG_ONE:(n=this.sub(t.mul(r)),i=r.add(n.div(t)),i));if(t.eq(f.MIN_VALUE))return this.unsigned?f.UZERO:f.ZERO;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=f.ZERO}for(n=this;n.gte(t);){r=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));const o=Math.ceil(Math.log(r)/Math.LN2),u=o<=48?1:Math.pow(2,o-48);let g=f.fromNumber(r),s=g.mul(t);for(;s.isNegative()||s.gt(n);)r-=u,g=f.fromNumber(r,this.unsigned),s=g.mul(t);g.isZero()&&(g=f.ONE),i=i.add(g),n=n.sub(s)}return i}div(t){return this.divide(t)}equals(t){return f.isLong(t)||(t=f.fromValue(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low}eq(t){return this.equals(t)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){if(this.isNegative())return this.eq(f.MIN_VALUE)?64:this.neg().getNumBitsAbs();const t=this.high!==0?this.high:this.low;let r;for(r=31;r>0&&!(t&1<<r);r--);return this.high!==0?r+33:r+1}greaterThan(t){return this.comp(t)>0}gt(t){return this.greaterThan(t)}greaterThanOrEqual(t){return this.comp(t)>=0}gte(t){return this.greaterThanOrEqual(t)}ge(t){return this.greaterThanOrEqual(t)}isEven(){return(this.low&1)===0}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return(this.low&1)===1}isPositive(){return this.unsigned||this.high>=0}isZero(){return this.high===0&&this.low===0}lessThan(t){return this.comp(t)<0}lt(t){return this.lessThan(t)}lessThanOrEqual(t){return this.comp(t)<=0}lte(t){return this.lessThanOrEqual(t)}modulo(t){if(f.isLong(t)||(t=f.fromValue(t)),J){const r=(this.unsigned?J.rem_u:J.rem_s)(this.low,this.high,t.low,t.high);return f.fromBits(r,J.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))}mod(t){return this.modulo(t)}rem(t){return this.modulo(t)}multiply(t){if(this.isZero())return f.ZERO;if(f.isLong(t)||(t=f.fromValue(t)),J){const p=J.mul(this.low,this.high,t.low,t.high);return f.fromBits(p,J.get_high(),this.unsigned)}if(t.isZero())return f.ZERO;if(this.eq(f.MIN_VALUE))return t.isOdd()?f.MIN_VALUE:f.ZERO;if(t.eq(f.MIN_VALUE))return this.isOdd()?f.MIN_VALUE:f.ZERO;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(f.TWO_PWR_24)&&t.lt(f.TWO_PWR_24))return f.fromNumber(this.toNumber()*t.toNumber(),this.unsigned);const r=this.high>>>16,n=this.high&65535,i=this.low>>>16,o=this.low&65535,u=t.high>>>16,g=t.high&65535,s=t.low>>>16,S=t.low&65535;let y=0,l=0,a=0,w=0;return w+=o*S,a+=w>>>16,w&=65535,a+=i*S,l+=a>>>16,a&=65535,a+=o*s,l+=a>>>16,a&=65535,l+=n*S,y+=l>>>16,l&=65535,l+=i*s,y+=l>>>16,l&=65535,l+=o*g,y+=l>>>16,l&=65535,y+=r*S+n*s+i*g+o*u,y&=65535,f.fromBits(a<<16|w,y<<16|l,this.unsigned)}mul(t){return this.multiply(t)}negate(){return!this.unsigned&&this.eq(f.MIN_VALUE)?f.MIN_VALUE:this.not().add(f.ONE)}neg(){return this.negate()}not(){return f.fromBits(~this.low,~this.high,this.unsigned)}notEquals(t){return!this.equals(t)}neq(t){return this.notEquals(t)}ne(t){return this.notEquals(t)}or(t){return f.isLong(t)||(t=f.fromValue(t)),f.fromBits(this.low|t.low,this.high|t.high,this.unsigned)}shiftLeft(t){return f.isLong(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?f.fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):f.fromBits(0,this.low<<t-32,this.unsigned)}shl(t){return this.shiftLeft(t)}shiftRight(t){return f.isLong(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?f.fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):f.fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)}shr(t){return this.shiftRight(t)}shiftRightUnsigned(t){if(f.isLong(t)&&(t=t.toInt()),t&=63,t===0)return this;{const r=this.high;if(t<32){const n=this.low;return f.fromBits(n>>>t|r<<32-t,r>>>t,this.unsigned)}else return t===32?f.fromBits(r,0,this.unsigned):f.fromBits(r>>>t-32,0,this.unsigned)}}shr_u(t){return this.shiftRightUnsigned(t)}shru(t){return this.shiftRightUnsigned(t)}subtract(t){return f.isLong(t)||(t=f.fromValue(t)),this.add(t.neg())}sub(t){return this.subtract(t)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){return this.unsigned?(this.high>>>0)*lt+(this.low>>>0):this.high*lt+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(t){return t?this.toBytesLE():this.toBytesBE()}toBytesLE(){const t=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]}toBytesBE(){const t=this.high,r=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,r>>>24,r>>>16&255,r>>>8&255,r&255]}toSigned(){return this.unsigned?f.fromBits(this.low,this.high,!1):this}toString(t){if(t=t||10,t<2||36<t)throw new c("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(f.MIN_VALUE)){const o=f.fromNumber(t),u=this.div(o),g=u.mul(o).sub(this);return u.toString(t)+g.toInt().toString(t)}else return"-"+this.neg().toString(t);const r=f.fromNumber(Math.pow(t,6),this.unsigned);let n=this,i="";for(;;){const o=n.div(r);let g=(n.sub(o.mul(r)).toInt()>>>0).toString(t);if(n=o,n.isZero())return g+i;for(;g.length<6;)g="0"+g;i=""+g+i}}toUnsigned(){return this.unsigned?this:f.fromBits(this.low,this.high,!0)}xor(t){return f.isLong(t)||(t=f.fromValue(t)),f.fromBits(this.low^t.low,this.high^t.high,this.unsigned)}eqz(){return this.isZero()}le(t){return this.lessThanOrEqual(t)}toExtendedJSON(t){return t&&t.relaxed?this.toNumber():{$numberLong:this.toString()}}static fromExtendedJSON(t,r){const{useBigInt64:n=!1,relaxed:i=!0}={...r};if(t.$numberLong.length>wn)throw new c("$numberLong string is too long");if(!pn.test(t.$numberLong))throw new c(`$numberLong string "${t.$numberLong}" is in an invalid format`);if(n){const u=BigInt(t.$numberLong);return BigInt.asIntN(64,u)}const o=f.fromString(t.$numberLong);return i?o.toNumber():o}inspect(t,r,n){n??=C;const i=n(this.toString(),r),o=this.unsigned?`, ${n(this.unsigned,r)}`:"";return`new Long(${i}${o})`}};f.TWO_PWR_24=f.fromInt(mn);f.MAX_UNSIGNED_VALUE=f.fromBits(-1,-1,!0);f.ZERO=f.fromInt(0);f.UZERO=f.fromInt(0,!0);f.ONE=f.fromInt(1);f.UONE=f.fromInt(1,!0);f.NEG_ONE=f.fromInt(-1);f.MAX_VALUE=f.fromBits(-1,0x7fffffff,!1);f.MIN_VALUE=f.fromBits(0,-0x80000000,!1);const bn=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/,Sn=/^(\+|-)?(Infinity|inf)$/i,Nn=/^(\+|-)?NaN$/i,rt=6111,pt=-6176,pe=6176,be=34,Rt=h.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Se=h.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Ne=h.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Bn=/^([-+])?(\d+)?$/,En=31,Be=16383,On=30,In=31;function Ee(e){return!isNaN(parseInt(e,10))}function dn(e){const t=f.fromNumber(1e9);let r=f.fromNumber(0);if(!e.parts[0]&&!e.parts[1]&&!e.parts[2]&&!e.parts[3])return{quotient:e,rem:r};for(let n=0;n<=3;n++)r=r.shiftLeft(32),r=r.add(new f(e.parts[n],0)),e.parts[n]=r.div(t).low,r=r.modulo(t);return{quotient:e,rem:r}}function Tn(e,t){if(!e&&!t)return{high:f.fromNumber(0),low:f.fromNumber(0)};const r=e.shiftRightUnsigned(32),n=new f(e.getLowBits(),0),i=t.shiftRightUnsigned(32),o=new f(t.getLowBits(),0);let u=r.multiply(i),g=r.multiply(o);const s=n.multiply(i);let S=n.multiply(o);return u=u.add(g.shiftRightUnsigned(32)),g=new f(g.getLowBits(),0).add(s).add(S.shiftRightUnsigned(32)),u=u.add(g.shiftRightUnsigned(32)),S=g.shiftLeft(32).add(new f(S.getLowBits(),0)),{high:u,low:S}}function $n(e,t){const r=e.high>>>0,n=t.high>>>0;if(r<n)return!0;if(r===n){const i=e.low>>>0,o=t.low>>>0;if(i<o)return!0}return!1}function V(e,t){throw new c(`"${e}" is not a valid Decimal128 string - ${t}`)}j=class extends P{get _bsontype(){return"Decimal128"}constructor(t){if(super(),typeof t=="string")this.bytes=j.fromString(t).bytes;else if(t instanceof Uint8Array||st(t)){if(t.byteLength!==16)throw new c("Decimal128 must take a Buffer of 16 bytes");this.bytes=t}else throw new c("Decimal128 must take a Buffer or string")}static fromString(t){return j._fromString(t,{allowRounding:!1})}static fromStringWithRounding(t){return j._fromString(t,{allowRounding:!0})}static _fromString(t,r){let n=!1,i=!1,o=!1,u=!1,g=0,s=0,S=0,y=0,l=0;const a=[0];let w=0,p=0,I=0,R=0,x=new f(0,0),_=new f(0,0),H=0,b=0;if(t.length>=7e3)throw new c(""+t+" not a valid Decimal128 string");const D=t.match(bn),d=t.match(Sn),E=t.match(Nn);if(!D&&!d&&!E||t.length===0)throw new c(""+t+" not a valid Decimal128 string");if(D){const m=D[2],B=D[4],$=D[5],z=D[6];B&&z===void 0&&V(t,"missing exponent power"),B&&m===void 0&&V(t,"missing exponent base"),B===void 0&&($||z)&&V(t,"missing e before exponent")}if((t[b]==="+"||t[b]==="-")&&(i=!0,n=t[b++]==="-"),!Ee(t[b])&&t[b]!=="."){if(t[b]==="i"||t[b]==="I")return new j(n?Se:Ne);if(t[b]==="N")return new j(Rt)}for(;Ee(t[b])||t[b]===".";){if(t[b]==="."){o&&V(t,"contains multiple periods"),o=!0,b=b+1;continue}w<be&&(t[b]!=="0"||u)&&(u||(l=s),u=!0,a[p++]=parseInt(t[b],10),w=w+1),u&&(S=S+1),o&&(y=y+1),s=s+1,b=b+1}if(o&&!s)throw new c(""+t+" not a valid Decimal128 string");if(t[b]==="e"||t[b]==="E"){const m=t.substr(++b).match(Bn);if(!m||!m[2])return new j(Rt);R=parseInt(m[0],10),b=b+m[0].length}if(t[b])return new j(Rt);if(!w)a[0]=0,S=1,w=1,g=0;else if(I=w-1,g=S,g!==1)for(;t[l+g-1+Number(i)+Number(o)]==="0";)g=g-1;for(R<=y&&y>R+16384?R=pt:R=R-y;R>rt;){if(I=I+1,I>=be){if(g===0){R=rt;break}V(t,"overflow")}R=R-1}if(r.allowRounding){for(;R<pt||w<S;){if(I===0&&g<w){R=pt,g=0;break}if(w<S?S=S-1:I=I-1,R<rt)R=R+1;else{if(a.join("").match(/^0+$/)){R=rt;break}V(t,"overflow")}}if(I+1<g){let m=s;o&&(l=l+1,m=m+1),i&&(l=l+1,m=m+1);const B=parseInt(t[l+I+1],10);let $=0;if(B>=5&&($=1,B===5)){$=a[I]%2===1?1:0;for(let z=l+I+2;z<m;z++)if(parseInt(t[z],10)){$=1;break}}if($){let z=I;for(;z>=0&&++a[z]>9;z--)if(a[z]=0,z===0)if(R<rt)R=R+1,a[z]=1;else return new j(n?Se:Ne)}}}else{for(;R<pt||w<S;){if(I===0){if(g===0){R=pt;break}V(t,"exponent underflow")}w<S?(t[S-1+Number(i)+Number(o)]!=="0"&&g!==0&&V(t,"inexact rounding"),S=S-1):(a[I]!==0&&V(t,"inexact rounding"),I=I-1),R<rt?R=R+1:V(t,"overflow")}I+1<g&&(o&&(l=l+1),i&&(l=l+1),parseInt(t[l+I+1],10)!==0&&V(t,"inexact rounding"))}if(x=f.fromNumber(0),_=f.fromNumber(0),g===0)x=f.fromNumber(0),_=f.fromNumber(0);else if(I<17){let m=0;for(_=f.fromNumber(a[m++]),x=new f(0,0);m<=I;m++)_=_.multiply(f.fromNumber(10)),_=_.add(f.fromNumber(a[m]))}else{let m=0;for(x=f.fromNumber(a[m++]);m<=I-17;m++)x=x.multiply(f.fromNumber(10)),x=x.add(f.fromNumber(a[m]));for(_=f.fromNumber(a[m++]);m<=I;m++)_=_.multiply(f.fromNumber(10)),_=_.add(f.fromNumber(a[m]))}const M=Tn(x,f.fromString("100000000000000000"));M.low=M.low.add(_),$n(M.low,_)&&(M.high=M.high.add(f.fromNumber(1))),H=R+pe;const T={low:f.fromNumber(0),high:f.fromNumber(0)};M.high.shiftRightUnsigned(49).and(f.fromNumber(1)).equals(f.fromNumber(1))?(T.high=T.high.or(f.fromNumber(3).shiftLeft(61)),T.high=T.high.or(f.fromNumber(H).and(f.fromNumber(16383).shiftLeft(47))),T.high=T.high.or(M.high.and(f.fromNumber(0x7fffffffffff)))):(T.high=T.high.or(f.fromNumber(H&16383).shiftLeft(49)),T.high=T.high.or(M.high.and(f.fromNumber(0x1ffffffffffff)))),T.low=M.low,n&&(T.high=T.high.or(f.fromString("9223372036854775808")));const N=h.allocateUnsafe(16);return b=0,N[b++]=T.low.low&255,N[b++]=T.low.low>>8&255,N[b++]=T.low.low>>16&255,N[b++]=T.low.low>>24&255,N[b++]=T.low.high&255,N[b++]=T.low.high>>8&255,N[b++]=T.low.high>>16&255,N[b++]=T.low.high>>24&255,N[b++]=T.high.low&255,N[b++]=T.high.low>>8&255,N[b++]=T.high.low>>16&255,N[b++]=T.high.low>>24&255,N[b++]=T.high.high&255,N[b++]=T.high.high>>8&255,N[b++]=T.high.high>>16&255,N[b++]=T.high.high>>24&255,new j(N)}toString(){let t,r=0;const n=new Array(36);for(let b=0;b<n.length;b++)n[b]=0;let i=0,o=!1,u,g={parts:[0,0,0,0]},s,S;const y=[];i=0;const l=this.bytes,a=l[i++]|l[i++]<<8|l[i++]<<16|l[i++]<<24,w=l[i++]|l[i++]<<8|l[i++]<<16|l[i++]<<24,p=l[i++]|l[i++]<<8|l[i++]<<16|l[i++]<<24,I=l[i++]|l[i++]<<8|l[i++]<<16|l[i++]<<24;i=0,{low:new f(a,w),high:new f(p,I)}.high.lessThan(f.ZERO)&&y.push("-");const x=I>>26&En;if(x>>3===3){if(x===On)return y.join("")+"Infinity";if(x===In)return"NaN";t=I>>15&Be,u=8+(I>>14&1)}else u=I>>14&7,t=I>>17&Be;const _=t-pe;if(g.parts[0]=(I&16383)+((u&15)<<14),g.parts[1]=p,g.parts[2]=w,g.parts[3]=a,g.parts[0]===0&&g.parts[1]===0&&g.parts[2]===0&&g.parts[3]===0)o=!0;else for(S=3;S>=0;S--){let b=0;const D=dn(g);if(g=D.quotient,b=D.rem.low,!!b)for(s=8;s>=0;s--)n[S*9+s]=b%10,b=Math.floor(b/10)}if(o)r=1,n[i]=0;else for(r=36;!n[i];)r=r-1,i=i+1;const H=r-1+_;if(H>=34||H<=-7||_>0){if(r>34)return y.push("0"),_>0?y.push(`E+${_}`):_<0&&y.push(`E${_}`),y.join("");y.push(`${n[i++]}`),r=r-1,r&&y.push(".");for(let b=0;b<r;b++)y.push(`${n[i++]}`);y.push("E"),H>0?y.push(`+${H}`):y.push(`${H}`)}else if(_>=0)for(let b=0;b<r;b++)y.push(`${n[i++]}`);else{let b=r+_;if(b>0)for(let D=0;D<b;D++)y.push(`${n[i++]}`);else y.push("0");for(y.push(".");b++<0;)y.push("0");for(let D=0;D<r-Math.max(b-1,0);D++)y.push(`${n[i++]}`)}return y.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(t){return j.fromString(t.$numberDecimal)}inspect(t,r,n){return n??=C,`new Decimal128(${n(this.toString(),r)})`}};W=class extends P{get _bsontype(){return"Double"}constructor(t){super(),t instanceof Number&&(t=t.valueOf()),this.value=+t}static fromString(t){const r=Number(t);if(t==="NaN")return new W(NaN);if(t==="Infinity")return new W(1/0);if(t==="-Infinity")return new W(-1/0);if(!Number.isFinite(r))throw new c(`Input: ${t} is not representable as a Double`);if(t.trim()!==t)throw new c(`Input: '${t}' contains whitespace`);if(t==="")throw new c("Input is an empty string");if(/[^-0-9.+eE]/.test(t))throw new c(`Input: '${t}' is not in decimal or exponential notation`);return new W(r)}valueOf(){return this.value}toJSON(){return this.value}toString(t){return this.value.toString(t)}toExtendedJSON(t){return t&&(t.legacy||t.relaxed&&isFinite(this.value))?this.value:Object.is(Math.sign(this.value),-0)?{$numberDouble:"-0.0"}:{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(t,r){const n=parseFloat(t.$numberDouble);return r&&r.relaxed?n:new W(n)}inspect(t,r,n){return n??=C,`new Double(${n(this.value,r)})`}};tt=class extends P{get _bsontype(){return"Int32"}constructor(t){super(),t instanceof Number&&(t=t.valueOf()),this.value=+t|0}static fromString(t){const r=Ye(t),n=Number(t);if(Bt<n)throw new c(`Input: '${t}' is larger than the maximum value for Int32`);if(Et>n)throw new c(`Input: '${t}' is smaller than the minimum value for Int32`);if(Number.isSafeInteger(n)){if(n.toString()!==r)throw new c(`Input: '${t}' is not a valid Int32 string`)}else throw new c(`Input: '${t}' is not a safe integer`);return new tt(n)}valueOf(){return this.value}toString(t){return this.value.toString(t)}toJSON(){return this.value}toExtendedJSON(t){return t&&(t.relaxed||t.legacy)?this.value:{$numberInt:this.value.toString()}}static fromExtendedJSON(t,r){return r&&r.relaxed?parseInt(t.$numberInt,10):new tt(t.$numberInt)}inspect(t,r,n){return n??=C,`new Int32(${n(this.value,r)})`}};gt=class extends P{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new gt}inspect(){return"new MaxKey()"}};yt=class extends P{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new yt}inspect(){return"new MinKey()"}};const ht=new Float64Array(1),U=new Uint8Array(ht.buffer,0,8);ht[0]=-1;const Oe=U[7]===0,O={getNonnegativeInt32LE(e,t){if(e[t+3]>127)throw new RangeError(`Size cannot be negative at offset: ${t}`);return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getInt32LE(e,t){return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getUint32LE(e,t){return e[t]+e[t+1]*256+e[t+2]*65536+e[t+3]*0x1000000},getUint32BE(e,t){return e[t+3]+e[t+2]*256+e[t+1]*65536+e[t]*0x1000000},getBigInt64LE(e,t){const r=O.getUint32LE(e,t),n=O.getUint32LE(e,t+4);return(BigInt(n)<<BigInt(32))+BigInt(r)},getFloat64LE:Oe?(e,t)=>(U[7]=e[t],U[6]=e[t+1],U[5]=e[t+2],U[4]=e[t+3],U[3]=e[t+4],U[2]=e[t+5],U[1]=e[t+6],U[0]=e[t+7],ht[0]):(e,t)=>(U[0]=e[t],U[1]=e[t+1],U[2]=e[t+2],U[3]=e[t+3],U[4]=e[t+4],U[5]=e[t+5],U[6]=e[t+6],U[7]=e[t+7],ht[0]),setInt32BE(e,t,r){return e[t+3]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t]=r,4},setInt32LE(e,t,r){return e[t]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+3]=r,4},setBigInt64LE(e,t,r){const n=BigInt(0xffffffff);let i=Number(r&n);e[t]=i,i>>=8,e[t+1]=i,i>>=8,e[t+2]=i,i>>=8,e[t+3]=i;let o=Number(r>>BigInt(32)&n);return e[t+4]=o,o>>=8,e[t+5]=o,o>>=8,e[t+6]=o,o>>=8,e[t+7]=o,8},setFloat64LE:Oe?(e,t,r)=>(ht[0]=r,e[t]=U[7],e[t+1]=U[6],e[t+2]=U[5],e[t+3]=U[4],e[t+4]=U[3],e[t+5]=U[2],e[t+6]=U[1],e[t+7]=U[0],8):(e,t,r)=>(ht[0]=r,e[t]=U[0],e[t+1]=U[1],e[t+2]=U[2],e[t+3]=U[3],e[t+4]=U[4],e[t+5]=U[5],e[t+6]=U[6],e[t+7]=U[7],8)};let et=null;L=class extends P{get _bsontype(){return"ObjectId"}constructor(t){super();let r;if(typeof t=="object"&&t&&"id"in t){if(typeof t.id!="string"&&!ArrayBuffer.isView(t.id))throw new c("Argument passed in must have an id that is of type string or Buffer");"toHexString"in t&&typeof t.toHexString=="function"?r=h.fromHex(t.toHexString()):r=t.id}else r=t;if(r==null||typeof r=="number")this.buffer=L.generate(typeof r=="number"?r:void 0);else if(ArrayBuffer.isView(r)&&r.byteLength===12)this.buffer=h.toLocalBufferType(r);else if(typeof r=="string")if(L.validateHexString(r))this.buffer=h.fromHex(r);else throw new c("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");else throw new c("Argument passed in does not match the accepted types");L.cacheHexString&&(this.__id=h.toHex(this.id))}get id(){return this.buffer}set id(t){this.buffer=t,L.cacheHexString&&(this.__id=h.toHex(t))}static validateHexString(t){if(t?.length!==24)return!1;for(let r=0;r<24;r++){const n=t.charCodeAt(r);if(!(n>=48&&n<=57||n>=97&&n<=102||n>=65&&n<=70))return!1}return!0}toHexString(){if(L.cacheHexString&&this.__id)return this.__id;const t=h.toHex(this.id);return L.cacheHexString&&!this.__id&&(this.__id=t),t}static getInc(){return L.index=(L.index+1)%0xffffff}static generate(t){typeof t!="number"&&(t=Math.floor(Date.now()/1e3));const r=L.getInc(),n=h.allocateUnsafe(12);return O.setInt32BE(n,0,t),et===null&&(et=h.randomBytes(5)),n[4]=et[0],n[5]=et[1],n[6]=et[2],n[7]=et[3],n[8]=et[4],n[11]=r&255,n[10]=r>>8&255,n[9]=r>>16&255,n}toString(t){return t==="base64"?h.toBase64(this.id):t==="hex"?this.toHexString():this.toHexString()}toJSON(){return this.toHexString()}static is(t){return t!=null&&typeof t=="object"&&"_bsontype"in t&&t._bsontype==="ObjectId"}equals(t){if(t==null)return!1;if(L.is(t))return this.buffer[11]===t.buffer[11]&&h.equals(this.buffer,t.buffer);if(typeof t=="string")return t.toLowerCase()===this.toHexString();if(typeof t=="object"&&typeof t.toHexString=="function"){const r=t.toHexString(),n=this.toHexString();return typeof r=="string"&&r.toLowerCase()===n}return!1}getTimestamp(){const t=new Date,r=O.getUint32BE(this.buffer,0);return t.setTime(Math.floor(r)*1e3),t}static createPk(){return new L}serializeInto(t,r){return t[r]=this.buffer[0],t[r+1]=this.buffer[1],t[r+2]=this.buffer[2],t[r+3]=this.buffer[3],t[r+4]=this.buffer[4],t[r+5]=this.buffer[5],t[r+6]=this.buffer[6],t[r+7]=this.buffer[7],t[r+8]=this.buffer[8],t[r+9]=this.buffer[9],t[r+10]=this.buffer[10],t[r+11]=this.buffer[11],12}static createFromTime(t){const r=h.allocate(12);for(let n=11;n>=4;n--)r[n]=0;return O.setInt32BE(r,0,t),new L(r)}static createFromHexString(t){if(t?.length!==24)throw new c("hex string must be 24 characters");return new L(h.fromHex(t))}static createFromBase64(t){if(t?.length!==16)throw new c("base64 string must be 16 characters");return new L(h.fromBase64(t))}static isValid(t){if(t==null)return!1;if(typeof t=="string")return L.validateHexString(t);try{return new L(t),!0}catch{return!1}}toExtendedJSON(){return this.toHexString?{$oid:this.toHexString()}:{$oid:this.toString("hex")}}static fromExtendedJSON(t){return new L(t.$oid)}inspect(t,r,n){return n??=C,`new ObjectId(${n(this.toHexString(),r)})`}};L.index=Math.floor(Math.random()*0xffffff);function dt(e,t,r){let n=5;if(Array.isArray(e))for(let i=0;i<e.length;i++)n+=Ie(i.toString(),e[i],t,!0,r);else{typeof e?.toBSON=="function"&&(e=e.toBSON());for(const i of Object.keys(e))n+=Ie(i,e[i],t,!1,r)}return n}function Ie(e,t,r=!1,n=!1,i=!1){switch(typeof t?.toBSON=="function"&&(t=t.toBSON()),typeof t){case"string":return 1+h.utf8ByteLength(e)+1+4+h.utf8ByteLength(t)+1;case"number":return Math.floor(t)===t&&t>=Ue&&t<=_e&&t>=Et&&t<=Bt?(e!=null?h.utf8ByteLength(e)+1:0)+5:(e!=null?h.utf8ByteLength(e)+1:0)+9;case"undefined":return n||!i?(e!=null?h.utf8ByteLength(e)+1:0)+1:0;case"boolean":return(e!=null?h.utf8ByteLength(e)+1:0)+2;case"object":if(t!=null&&typeof t._bsontype=="string"&&t[ct]!==nt)throw new ut;if(t==null||t._bsontype==="MinKey"||t._bsontype==="MaxKey")return(e!=null?h.utf8ByteLength(e)+1:0)+1;if(t._bsontype==="ObjectId")return(e!=null?h.utf8ByteLength(e)+1:0)+13;if(t instanceof Date||ft(t))return(e!=null?h.utf8ByteLength(e)+1:0)+9;if(ArrayBuffer.isView(t)||t instanceof ArrayBuffer||ee(t))return(e!=null?h.utf8ByteLength(e)+1:0)+6+t.byteLength;if(t._bsontype==="Long"||t._bsontype==="Double"||t._bsontype==="Timestamp")return(e!=null?h.utf8ByteLength(e)+1:0)+9;if(t._bsontype==="Decimal128")return(e!=null?h.utf8ByteLength(e)+1:0)+17;if(t._bsontype==="Code")return t.scope!=null&&Object.keys(t.scope).length>0?(e!=null?h.utf8ByteLength(e)+1:0)+1+4+4+h.utf8ByteLength(t.code.toString())+1+dt(t.scope,r,i):(e!=null?h.utf8ByteLength(e)+1:0)+1+4+h.utf8ByteLength(t.code.toString())+1;if(t._bsontype==="Binary"){const o=t;return o.sub_type===A.SUBTYPE_BYTE_ARRAY?(e!=null?h.utf8ByteLength(e)+1:0)+(o.position+1+4+1+4):(e!=null?h.utf8ByteLength(e)+1:0)+(o.position+1+4+1)}else{if(t._bsontype==="Symbol")return(e!=null?h.utf8ByteLength(e)+1:0)+h.utf8ByteLength(t.value)+4+1+1;if(t._bsontype==="DBRef"){const o=Object.assign({$ref:t.collection,$id:t.oid},t.fields);return t.db!=null&&(o.$db=t.db),(e!=null?h.utf8ByteLength(e)+1:0)+1+dt(o,r,i)}else return t instanceof RegExp||ot(t)?(e!=null?h.utf8ByteLength(e)+1:0)+1+h.utf8ByteLength(t.source)+1+(t.global?1:0)+(t.ignoreCase?1:0)+(t.multiline?1:0)+1:t._bsontype==="BSONRegExp"?(e!=null?h.utf8ByteLength(e)+1:0)+1+h.utf8ByteLength(t.pattern)+1+h.utf8ByteLength(t.options)+1:(e!=null?h.utf8ByteLength(e)+1:0)+dt(t,r,i)+1}case"function":if(r)return(e!=null?h.utf8ByteLength(e)+1:0)+1+4+h.utf8ByteLength(t.toString())+1}return 0}function An(e){return e.split("").sort().join("")}k=class extends P{get _bsontype(){return"BSONRegExp"}constructor(t,r){if(super(),this.pattern=t,this.options=An(r??""),this.pattern.indexOf("\0")!==-1)throw new c(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);if(this.options.indexOf("\0")!==-1)throw new c(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);for(let n=0;n<this.options.length;n++)if(!(this.options[n]==="i"||this.options[n]==="m"||this.options[n]==="x"||this.options[n]==="l"||this.options[n]==="s"||this.options[n]==="u"))throw new c(`The regular expression option [${this.options[n]}] is not supported`)}static parseOptions(t){return t?t.split("").sort().join(""):""}toExtendedJSON(t){return t=t||{},t.legacy?{$regex:this.pattern,$options:this.options}:{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(t){if("$regex"in t)if(typeof t.$regex!="string"){if(t.$regex._bsontype==="BSONRegExp")return t}else return new k(t.$regex,k.parseOptions(t.$options));if("$regularExpression"in t)return new k(t.$regularExpression.pattern,k.parseOptions(t.$regularExpression.options));throw new c(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(t)}`)}inspect(t,r,n){const i=ve(r)??(g=>g);n??=C;const o=i(n(this.pattern),"regexp"),u=i(n(this.options),"regexp");return`new BSONRegExp(${o}, ${u})`}};mt=class extends P{get _bsontype(){return"BSONSymbol"}constructor(t){super(),this.value=t}valueOf(){return this.value}toString(){return this.value}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(t){return new mt(t.$symbol)}inspect(t,r,n){return n??=C,`new BSONSymbol(${n(this.value,r)})`}};const _n=f;Y=class extends _n{get _bsontype(){return"Timestamp"}get i(){return this.low>>>0}get t(){return this.high>>>0}constructor(t){if(t==null)super(0,0,!0);else if(typeof t=="bigint")super(t,!0);else if(f.isLong(t))super(t.low,t.high,!0);else if(typeof t=="object"&&"t"in t&&"i"in t){if(typeof t.t!="number"&&(typeof t.t!="object"||t.t._bsontype!=="Int32"))throw new c("Timestamp constructed from { t, i } must provide t as a number");if(typeof t.i!="number"&&(typeof t.i!="object"||t.i._bsontype!=="Int32"))throw new c("Timestamp constructed from { t, i } must provide i as a number");const r=Number(t.t),n=Number(t.i);if(r<0||Number.isNaN(r))throw new c("Timestamp constructed from { t, i } must provide a positive t");if(n<0||Number.isNaN(n))throw new c("Timestamp constructed from { t, i } must provide a positive i");if(r>0xffffffff)throw new c("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");if(n>0xffffffff)throw new c("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");super(n,r,!0)}else throw new c("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }")}toJSON(){return{$timestamp:this.toString()}}static fromInt(t){return new Y(f.fromInt(t,!0))}static fromNumber(t){return new Y(f.fromNumber(t,!0))}static fromBits(t,r){return new Y({i:t,t:r})}static fromString(t,r){return new Y(f.fromString(t,!0,r))}toExtendedJSON(){return{$timestamp:{t:this.t,i:this.i}}}static fromExtendedJSON(t){const r=f.isLong(t.$timestamp.i)?t.$timestamp.i.getLowBitsUnsigned():t.$timestamp.i,n=f.isLong(t.$timestamp.t)?t.$timestamp.t.getLowBitsUnsigned():t.$timestamp.t;return new Y({t:n,i:r})}inspect(t,r,n){n??=C;const i=n(this.t,r),o=n(this.i,r);return`new Timestamp({ t: ${i}, i: ${o} })`}};Y.MAX_VALUE=f.MAX_UNSIGNED_VALUE;const Un=f.fromNumber(_e),Rn=f.fromNumber(Ue);function Ze(e,t,r){t=t??{};const n=t&&t.index?t.index:0,i=O.getInt32LE(e,n);if(i<5)throw new c(`bson size must be >= 5, is ${i}`);if(t.allowObjectSmallerThanBufferSize&&e.length<i)throw new c(`buffer length ${e.length} must be >= bson size ${i}`);if(!t.allowObjectSmallerThanBufferSize&&e.length!==i)throw new c(`buffer length ${e.length} must === bson size ${i}`);if(i+n>e.byteLength)throw new c(`(bson size ${i} + options.index ${n} must be <= buffer length ${e.byteLength})`);if(e[n+i-1]!==0)throw new c("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return Tt(e,n,t,r)}const Ln=/^\$ref$|^\$id$|^\$db$/;function Tt(e,t,r,n=!1){const i=r.fieldsAsRaw==null?null:r.fieldsAsRaw,o=r.raw==null?!1:r.raw,u=typeof r.bsonRegExp=="boolean"?r.bsonRegExp:!1,g=r.promoteBuffers??!1,s=r.promoteLongs??!0,S=r.promoteValues??!0,y=r.useBigInt64??!1;if(y&&!S)throw new c("Must either request bigint or Long for int64 deserialization");if(y&&!s)throw new c("Must either request bigint or Long for int64 deserialization");const l=r.validation==null?{utf8:!0}:r.validation;let a=!0,w,p;const I=l.utf8;if(typeof I=="boolean")w=I;else{a=!1;const d=Object.keys(I).map(function(E){return I[E]});if(d.length===0)throw new c("UTF-8 validation setting cannot be empty");if(typeof d[0]!="boolean")throw new c("Invalid UTF-8 validation option, must specify boolean values");if(w=d[0],!d.every(E=>E===w))throw new c("Invalid UTF-8 validation option - keys must be all true or all false")}if(!a){p=new Set;for(const d of Object.keys(I))p.add(d)}const R=t;if(e.length<5)throw new c("corrupt bson message < 5 bytes long");const x=O.getInt32LE(e,t);if(t+=4,x<5||x>e.length)throw new c("corrupt bson message");const _=n?[]:{};let H=0;const b=!1;let D=n?!1:null;for(;!b;){const d=e[t++];if(d===0)break;let E=t;for(;e[E]!==0&&E<e.length;)E++;if(E>=e.byteLength)throw new c("Bad BSON Document: illegal CString");const M=n?H++:h.toUTF8(e,t,E,!1);let T=!0;a||p?.has(M)?T=w:T=!w,D!==!1&&M[0]==="$"&&(D=Ln.test(M));let N;if(t=E+1,d===Re){const m=O.getInt32LE(e,t);if(t+=4,m<=0||m>e.length-t||e[t+m-1]!==0)throw new c("bad string length in bson");N=h.toUTF8(e,t,t+m-1,T),t=t+m}else if(d===De){const m=h.allocateUnsafe(12);for(let B=0;B<12;B++)m[B]=e[t+B];N=new L(m),t=t+12}else if(d===bt&&S===!1)N=new tt(O.getInt32LE(e,t)),t+=4;else if(d===bt)N=O.getInt32LE(e,t),t+=4;else if(d===re)N=O.getFloat64LE(e,t),t+=8,S===!1&&(N=new W(N));else if(d===Me){const m=O.getInt32LE(e,t),B=O.getInt32LE(e,t+4);t+=8,N=new Date(new f(m,B).toNumber())}else if(d===ze){if(e[t]!==0&&e[t]!==1)throw new c("illegal boolean type value");N=e[t++]===1}else if(d===ie){const m=t,B=O.getInt32LE(e,t);if(B<=0||B>e.length-t)throw new c("bad embedded document length in bson");if(o)N=e.slice(t,t+B);else{let $=r;a||($={...r,validation:{utf8:T}}),N=Tt(e,m,$,!1)}t=t+B}else if(d===Le){const m=t,B=O.getInt32LE(e,t);let $=r;const z=t+B;if(i&&i[M]&&($={...r,raw:!0}),a||($={...$,validation:{utf8:T}}),N=Tt(e,m,$,!0),t=t+B,e[t-1]!==0)throw new c("invalid array terminator byte");if(t!==z)throw new c("corrupted array bson")}else if(d===tn)N=void 0;else if(d===oe)N=null;else if(d===le)if(y)N=O.getBigInt64LE(e,t),t+=8;else{const m=O.getInt32LE(e,t),B=O.getInt32LE(e,t+4);t+=8;const $=new f(m,B);s&&S===!0?N=$.lessThanOrEqual(Un)&&$.greaterThanOrEqual(Rn)?$.toNumber():$:N=$}else if(d===Ce){const m=h.allocateUnsafe(16);for(let B=0;B<16;B++)m[B]=e[t+B];t=t+16,N=new j(m)}else if(d===se){let m=O.getInt32LE(e,t);t+=4;const B=m,$=e[t++];if(m<0)throw new c("Negative binary type element size found");if(m>e.byteLength)throw new c("Binary type size larger than document size");if(e.slice!=null){if($===A.SUBTYPE_BYTE_ARRAY){if(m=O.getInt32LE(e,t),t+=4,m<0)throw new c("Negative binary type element size found for subtype 0x02");if(m>B-4)throw new c("Binary type with subtype 0x02 contains too long binary size");if(m<B-4)throw new c("Binary type with subtype 0x02 contains too short binary size")}g&&S?N=h.toLocalBufferType(e.slice(t,t+m)):(N=new A(e.slice(t,t+m),$),$===At&&F.isValid(N)&&(N=N.toUUID()))}else{if($===A.SUBTYPE_BYTE_ARRAY){if(m=O.getInt32LE(e,t),t+=4,m<0)throw new c("Negative binary type element size found for subtype 0x02");if(m>B-4)throw new c("Binary type with subtype 0x02 contains too long binary size");if(m<B-4)throw new c("Binary type with subtype 0x02 contains too short binary size")}if(g&&S)for(N=h.allocateUnsafe(m),E=0;E<m;E++)N[E]=e[t+E];else N=new A(e.slice(t,t+m),$),$===At&&F.isValid(N)&&(N=N.toUUID())}t=t+m}else if(d===$t&&u===!1){for(E=t;e[E]!==0&&E<e.length;)E++;if(E>=e.length)throw new c("Bad BSON Document: illegal CString");const m=h.toUTF8(e,t,E,!1);for(t=E+1,E=t;e[E]!==0&&E<e.length;)E++;if(E>=e.length)throw new c("Bad BSON Document: illegal CString");const B=h.toUTF8(e,t,E,!1);t=E+1;const $=new Array(B.length);for(E=0;E<B.length;E++)switch(B[E]){case"m":$[E]="m";break;case"s":$[E]="g";break;case"i":$[E]="i";break}N=new RegExp(m,$.join(""))}else if(d===$t&&u===!0){for(E=t;e[E]!==0&&E<e.length;)E++;if(E>=e.length)throw new c("Bad BSON Document: illegal CString");const m=h.toUTF8(e,t,E,!1);for(t=E+1,E=t;e[E]!==0&&E<e.length;)E++;if(E>=e.length)throw new c("Bad BSON Document: illegal CString");const B=h.toUTF8(e,t,E,!1);t=E+1,N=new k(m,B)}else if(d===xe){const m=O.getInt32LE(e,t);if(t+=4,m<=0||m>e.length-t||e[t+m-1]!==0)throw new c("bad string length in bson");const B=h.toUTF8(e,t,t+m-1,T);N=S?B:new mt(B),t=t+m}else if(d===je)N=new Y({i:O.getUint32LE(e,t),t:O.getUint32LE(e,t+4)}),t+=8;else if(d===Pe)N=new yt;else if(d===Je)N=new gt;else if(d===fe){const m=O.getInt32LE(e,t);if(t+=4,m<=0||m>e.length-t||e[t+m-1]!==0)throw new c("bad string length in bson");const B=h.toUTF8(e,t,t+m-1,T);N=new v(B),t=t+m}else if(d===Fe){const m=O.getInt32LE(e,t);if(t+=4,m<13)throw new c("code_w_scope total size shorter minimum expected length");const B=O.getInt32LE(e,t);if(t+=4,B<=0||B>e.length-t||e[t+B-1]!==0)throw new c("bad string length in bson");const $=h.toUTF8(e,t,t+B-1,T);t=t+B;const z=t,G=O.getInt32LE(e,t),Qe=Tt(e,z,r,!1);if(t=t+G,m<8+G+B)throw new c("code_w_scope total size is too short, truncating scope");if(m>8+G+B)throw new c("code_w_scope total size is too long, clips outer document");N=new v($,Qe)}else if(d===en){const m=O.getInt32LE(e,t);if(t+=4,m<=0||m>e.length-t||e[t+m-1]!==0)throw new c("bad string length in bson");const B=h.toUTF8(e,t,t+m-1,T);t=t+m;const $=h.allocateUnsafe(12);for(let G=0;G<12;G++)$[G]=e[t+G];const z=new L($);t=t+12,N=new K(B,z)}else throw new c(`Detected unknown BSON type ${d.toString(16)} for fieldname "${M}"`);M==="__proto__"?Object.defineProperty(_,M,{value:N,writable:!0,enumerable:!0,configurable:!0}):_[M]=N}if(x!==t-R)throw n?new c("corrupt array bson"):new c("corrupt object bson");if(!D)return _;if(We(_)){const d=Object.assign({},_);return delete d.$ref,delete d.$id,delete d.$db,new K(_.$ref,_.$id,_.$db,d)}return _}const _t=/\x00/,de=new Set(["$db","$ref","$id","$clusterTime"]);function Lt(e,t,r,n){e[n++]=Re;const i=h.encodeUTF8Into(e,t,n);n=n+i+1,e[n-1]=0;const o=h.encodeUTF8Into(e,r,n+4);return O.setInt32LE(e,n,o+1),n=n+4+o,e[n++]=0,n}function Dt(e,t,r,n){const o=!Object.is(r,-0)&&Number.isSafeInteger(r)&&r<=Bt&&r>=Et?bt:re;e[n++]=o;const u=h.encodeUTF8Into(e,t,n);return n=n+u,e[n++]=0,o===bt?n+=O.setInt32LE(e,n,r):n+=O.setFloat64LE(e,n,r),n}function zt(e,t,r,n){e[n++]=le;const i=h.encodeUTF8Into(e,t,n);return n+=i,e[n++]=0,n+=O.setBigInt64LE(e,n,r),n}function it(e,t,r,n){e[n++]=oe;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function Mt(e,t,r,n){e[n++]=ze;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,e[n++]=r?1:0,n}function xt(e,t,r,n){e[n++]=Me;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=f.fromNumber(r.getTime()),u=o.getLowBits(),g=o.getHighBits();return n+=O.setInt32LE(e,n,u),n+=O.setInt32LE(e,n,g),n}function Ft(e,t,r,n){e[n++]=$t;const i=h.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.source&&r.source.match(_t)!=null)throw new c("value "+r.source+" must not contain null bytes");return n=n+h.encodeUTF8Into(e,r.source,n),e[n++]=0,r.ignoreCase&&(e[n++]=105),r.global&&(e[n++]=115),r.multiline&&(e[n++]=109),e[n++]=0,n}function jt(e,t,r,n){e[n++]=$t;const i=h.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.pattern.match(_t)!=null)throw new c("pattern "+r.pattern+" must not contain null bytes");n=n+h.encodeUTF8Into(e,r.pattern,n),e[n++]=0;const o=r.options.split("").sort().join("");return n=n+h.encodeUTF8Into(e,o,n),e[n++]=0,n}function Ct(e,t,r,n){r===null?e[n++]=oe:r._bsontype==="MinKey"?e[n++]=Pe:e[n++]=Je;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function Pt(e,t,r,n){e[n++]=De;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=r.serializeInto(e,n),n}function Jt(e,t,r,n){e[n++]=se;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=r.length;if(n+=O.setInt32LE(e,n,o),e[n++]=nn,o<=16)for(let u=0;u<o;u++)e[n+u]=r[u];else e.set(r,n);return n=n+o,n}function Ht(e,t,r,n,i,o,u,g,s){if(s.has(r))throw new c("Cannot convert circular structure to BSON");s.add(r),e[n++]=Array.isArray(r)?Le:ie;const S=h.encodeUTF8Into(e,t,n);n=n+S,e[n++]=0;const y=Ot(e,r,i,n,o+1,u,g,s);return s.delete(r),y}function Vt(e,t,r,n){e[n++]=Ce;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;for(let o=0;o<16;o++)e[n+o]=r.bytes[o];return n+16}function Wt(e,t,r,n){e[n++]=r._bsontype==="Long"?le:je;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=r.getLowBits(),u=r.getHighBits();return n+=O.setInt32LE(e,n,o),n+=O.setInt32LE(e,n,u),n}function Yt(e,t,r,n){r=r.valueOf(),e[n++]=bt;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=O.setInt32LE(e,n,r),n}function kt(e,t,r,n){e[n++]=re;const i=h.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=O.setFloat64LE(e,n,r.value),n}function Zt(e,t,r,n){e[n++]=fe;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=r.toString(),u=h.encodeUTF8Into(e,o,n+4)+1;return O.setInt32LE(e,n,u),n=n+4+u-1,e[n++]=0,n}function qt(e,t,r,n,i=!1,o=0,u=!1,g=!0,s){if(r.scope&&typeof r.scope=="object"){e[n++]=Fe;const S=h.encodeUTF8Into(e,t,n);n=n+S,e[n++]=0;let y=n;const l=r.code;n=n+4;const a=h.encodeUTF8Into(e,l,n+4)+1;O.setInt32LE(e,n,a),e[n+4+a-1]=0,n=n+a+4;const w=Ot(e,r.scope,i,n,o+1,u,g,s);n=w-1;const p=w-y;y+=O.setInt32LE(e,y,p),e[n++]=0}else{e[n++]=fe;const S=h.encodeUTF8Into(e,t,n);n=n+S,e[n++]=0;const y=r.code.toString(),l=h.encodeUTF8Into(e,y,n+4)+1;O.setInt32LE(e,n,l),n=n+4+l-1,e[n++]=0}return n}function Kt(e,t,r,n){e[n++]=se;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=r.buffer;let u=r.position;if(r.sub_type===A.SUBTYPE_BYTE_ARRAY&&(u=u+4),n+=O.setInt32LE(e,n,u),e[n++]=r.sub_type,r.sub_type===A.SUBTYPE_BYTE_ARRAY&&(u=u-4,n+=O.setInt32LE(e,n,u)),u<=16)for(let g=0;g<u;g++)e[n+g]=o[g];else e.set(o,n);return n=n+r.position,n}function Gt(e,t,r,n){e[n++]=xe;const i=h.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const o=h.encodeUTF8Into(e,r.value,n+4)+1;return O.setInt32LE(e,n,o),n=n+4+o-1,e[n++]=0,n}function Xt(e,t,r,n,i,o,u){e[n++]=ie;const g=h.encodeUTF8Into(e,t,n);n=n+g,e[n++]=0;let s=n,S={$ref:r.collection||r.namespace,$id:r.oid};r.db!=null&&(S.$db=r.db),S=Object.assign(S,r.fields);const y=Ot(e,S,!1,n,i+1,o,!0,u),l=y-s;return s+=O.setInt32LE(e,n,l),y}function Ot(e,t,r,n,i,o,u,g){if(g==null){if(t==null)return e[0]=5,e[1]=0,e[2]=0,e[3]=0,e[4]=0,5;if(Array.isArray(t))throw new c("serialize does not support an array as the root input");if(typeof t!="object")throw new c("serialize does not support non-object as the root input");if("_bsontype"in t&&typeof t._bsontype=="string")throw new c("BSON types cannot be serialized as a document");if(ft(t)||ot(t)||st(t)||ee(t))throw new c("date, regexp, typedarray, and arraybuffer cannot be BSON documents");g=new Set}g.add(t);let s=n+4;if(Array.isArray(t))for(let y=0;y<t.length;y++){const l=`${y}`;let a=t[y];typeof a?.toBSON=="function"&&(a=a.toBSON());const w=typeof a;if(a===void 0)s=it(e,l,a,s);else if(a===null)s=it(e,l,a,s);else if(w==="string")s=Lt(e,l,a,s);else if(w==="number")s=Dt(e,l,a,s);else if(w==="bigint")s=zt(e,l,a,s);else if(w==="boolean")s=Mt(e,l,a,s);else if(w==="object"&&a._bsontype==null)a instanceof Date||ft(a)?s=xt(e,l,a,s):a instanceof Uint8Array||st(a)?s=Jt(e,l,a,s):a instanceof RegExp||ot(a)?s=Ft(e,l,a,s):s=Ht(e,l,a,s,r,i,o,u,g);else if(w==="object"){if(a[ct]!==nt)throw new ut;if(a._bsontype==="ObjectId")s=Pt(e,l,a,s);else if(a._bsontype==="Decimal128")s=Vt(e,l,a,s);else if(a._bsontype==="Long"||a._bsontype==="Timestamp")s=Wt(e,l,a,s);else if(a._bsontype==="Double")s=kt(e,l,a,s);else if(a._bsontype==="Code")s=qt(e,l,a,s,r,i,o,u,g);else if(a._bsontype==="Binary")s=Kt(e,l,a,s);else if(a._bsontype==="BSONSymbol")s=Gt(e,l,a,s);else if(a._bsontype==="DBRef")s=Xt(e,l,a,s,i,o,g);else if(a._bsontype==="BSONRegExp")s=jt(e,l,a,s);else if(a._bsontype==="Int32")s=Yt(e,l,a,s);else if(a._bsontype==="MinKey"||a._bsontype==="MaxKey")s=Ct(e,l,a,s);else if(typeof a._bsontype<"u")throw new c(`Unrecognized or invalid _bsontype: ${String(a._bsontype)}`)}else w==="function"&&o&&(s=Zt(e,l,a,s))}else if(t instanceof Map||ne(t)){const y=t.entries();let l=!1;for(;!l;){const a=y.next();if(l=!!a.done,l)continue;const w=a.value[0];let p=a.value[1];typeof p?.toBSON=="function"&&(p=p.toBSON());const I=typeof p;if(typeof w=="string"&&!de.has(w)){if(w.match(_t)!=null)throw new c("key "+w+" must not contain null bytes");if(r){if(w[0]==="$")throw new c("key "+w+" must not start with '$'");if(w.includes("."))throw new c("key "+w+" must not contain '.'")}}if(p===void 0)u===!1&&(s=it(e,w,p,s));else if(p===null)s=it(e,w,p,s);else if(I==="string")s=Lt(e,w,p,s);else if(I==="number")s=Dt(e,w,p,s);else if(I==="bigint")s=zt(e,w,p,s);else if(I==="boolean")s=Mt(e,w,p,s);else if(I==="object"&&p._bsontype==null)p instanceof Date||ft(p)?s=xt(e,w,p,s):p instanceof Uint8Array||st(p)?s=Jt(e,w,p,s):p instanceof RegExp||ot(p)?s=Ft(e,w,p,s):s=Ht(e,w,p,s,r,i,o,u,g);else if(I==="object"){if(p[ct]!==nt)throw new ut;if(p._bsontype==="ObjectId")s=Pt(e,w,p,s);else if(p._bsontype==="Decimal128")s=Vt(e,w,p,s);else if(p._bsontype==="Long"||p._bsontype==="Timestamp")s=Wt(e,w,p,s);else if(p._bsontype==="Double")s=kt(e,w,p,s);else if(p._bsontype==="Code")s=qt(e,w,p,s,r,i,o,u,g);else if(p._bsontype==="Binary")s=Kt(e,w,p,s);else if(p._bsontype==="BSONSymbol")s=Gt(e,w,p,s);else if(p._bsontype==="DBRef")s=Xt(e,w,p,s,i,o,g);else if(p._bsontype==="BSONRegExp")s=jt(e,w,p,s);else if(p._bsontype==="Int32")s=Yt(e,w,p,s);else if(p._bsontype==="MinKey"||p._bsontype==="MaxKey")s=Ct(e,w,p,s);else if(typeof p._bsontype<"u")throw new c(`Unrecognized or invalid _bsontype: ${String(p._bsontype)}`)}else I==="function"&&o&&(s=Zt(e,w,p,s))}}else{if(typeof t?.toBSON=="function"&&(t=t.toBSON(),t!=null&&typeof t!="object"))throw new c("toBSON function did not return an object");for(const y of Object.keys(t)){let l=t[y];typeof l?.toBSON=="function"&&(l=l.toBSON());const a=typeof l;if(typeof y=="string"&&!de.has(y)){if(y.match(_t)!=null)throw new c("key "+y+" must not contain null bytes");if(r){if(y[0]==="$")throw new c("key "+y+" must not start with '$'");if(y.includes("."))throw new c("key "+y+" must not contain '.'")}}if(l===void 0)u===!1&&(s=it(e,y,l,s));else if(l===null)s=it(e,y,l,s);else if(a==="string")s=Lt(e,y,l,s);else if(a==="number")s=Dt(e,y,l,s);else if(a==="bigint")s=zt(e,y,l,s);else if(a==="boolean")s=Mt(e,y,l,s);else if(a==="object"&&l._bsontype==null)l instanceof Date||ft(l)?s=xt(e,y,l,s):l instanceof Uint8Array||st(l)?s=Jt(e,y,l,s):l instanceof RegExp||ot(l)?s=Ft(e,y,l,s):s=Ht(e,y,l,s,r,i,o,u,g);else if(a==="object"){if(l[ct]!==nt)throw new ut;if(l._bsontype==="ObjectId")s=Pt(e,y,l,s);else if(l._bsontype==="Decimal128")s=Vt(e,y,l,s);else if(l._bsontype==="Long"||l._bsontype==="Timestamp")s=Wt(e,y,l,s);else if(l._bsontype==="Double")s=kt(e,y,l,s);else if(l._bsontype==="Code")s=qt(e,y,l,s,r,i,o,u,g);else if(l._bsontype==="Binary")s=Kt(e,y,l,s);else if(l._bsontype==="BSONSymbol")s=Gt(e,y,l,s);else if(l._bsontype==="DBRef")s=Xt(e,y,l,s,i,o,g);else if(l._bsontype==="BSONRegExp")s=jt(e,y,l,s);else if(l._bsontype==="Int32")s=Yt(e,y,l,s);else if(l._bsontype==="MinKey"||l._bsontype==="MaxKey")s=Ct(e,y,l,s);else if(typeof l._bsontype<"u")throw new c(`Unrecognized or invalid _bsontype: ${String(l._bsontype)}`)}else a==="function"&&o&&(s=Zt(e,y,l,s))}}g.delete(t),e[s++]=0;const S=s-n;return n+=O.setInt32LE(e,n,S),s}function Dn(e){return e!=null&&typeof e=="object"&&"_bsontype"in e&&typeof e._bsontype=="string"}const zn={$oid:L,$binary:A,$uuid:A,$symbol:mt,$numberInt:tt,$numberDecimal:j,$numberDouble:W,$numberLong:f,$minKey:yt,$maxKey:gt,$regex:k,$regularExpression:k,$timestamp:Y};function qe(e,t={}){if(typeof e=="number"){const n=e<=Bt&&e>=Et,i=e<=$e&&e>=Ae;if(t.relaxed||t.legacy)return e;if(Number.isInteger(e)&&!Object.is(e,-0)){if(n)return new tt(e);if(i)return t.useBigInt64?BigInt(e):f.fromNumber(e)}return new W(e)}if(e==null||typeof e!="object")return e;if(e.$undefined)return null;const r=Object.keys(e).filter(n=>n.startsWith("$")&&e[n]!=null);for(let n=0;n<r.length;n++){const i=zn[r[n]];if(i)return i.fromExtendedJSON(e,t)}if(e.$date!=null){const n=e.$date,i=new Date;if(t.legacy)if(typeof n=="number")i.setTime(n);else if(typeof n=="string")i.setTime(Date.parse(n));else if(typeof n=="bigint")i.setTime(Number(n));else throw new te(`Unrecognized type for EJSON date: ${typeof n}`);else if(typeof n=="string")i.setTime(Date.parse(n));else if(f.isLong(n))i.setTime(n.toNumber());else if(typeof n=="number"&&t.relaxed)i.setTime(n);else if(typeof n=="bigint")i.setTime(Number(n));else throw new te(`Unrecognized type for EJSON date: ${typeof n}`);return i}if(e.$code!=null){const n=Object.assign({},e);return e.$scope&&(n.$scope=qe(e.$scope)),v.fromExtendedJSON(e)}if(We(e)||e.$dbPointer){const n=e.$ref?e:e.$dbPointer;if(n instanceof K)return n;const i=Object.keys(n).filter(u=>u.startsWith("$"));let o=!0;if(i.forEach(u=>{["$ref","$id","$db"].indexOf(u)===-1&&(o=!1)}),o)return K.fromExtendedJSON(n)}return e}function Mn(e,t){return e.map((r,n)=>{t.seenObjects.push({propertyName:`index ${n}`,obj:null});try{return q(r,t)}finally{t.seenObjects.pop()}})}function Te(e){const t=e.toISOString();return e.getUTCMilliseconds()!==0?t:t.slice(0,-5)+"Z"}function q(e,t){if(e instanceof Map||ne(e)){const r=Object.create(null);for(const[n,i]of e){if(typeof n!="string")throw new c("Can only serialize maps with string keys");r[n]=i}return q(r,t)}if((typeof e=="object"||typeof e=="function")&&e!==null){const r=t.seenObjects.findIndex(n=>n.obj===e);if(r!==-1){const n=t.seenObjects.map(y=>y.propertyName),i=n.slice(0,r).map(y=>`${y} -> `).join(""),o=n[r],u=" -> "+n.slice(r+1,n.length-1).map(y=>`${y} -> `).join(""),g=n[n.length-1],s=" ".repeat(i.length+o.length/2),S="-".repeat(u.length+(o.length+g.length)/2-1);throw new c(`Converting circular structure to EJSON:
    ${i}${o}${u}${g}
    ${s}\\${S}/`)}t.seenObjects[t.seenObjects.length-1].obj=e}if(Array.isArray(e))return Mn(e,t);if(e===void 0)return null;if(e instanceof Date||ft(e)){const r=e.getTime(),n=r>-1&&r<2534023188e5;return t.legacy?t.relaxed&&n?{$date:e.getTime()}:{$date:Te(e)}:t.relaxed&&n?{$date:Te(e)}:{$date:{$numberLong:e.getTime().toString()}}}if(typeof e=="number"&&(!t.relaxed||!isFinite(e))){if(Number.isInteger(e)&&!Object.is(e,-0)){if(e>=Et&&e<=Bt)return{$numberInt:e.toString()};if(e>=Ae&&e<=$e)return{$numberLong:e.toString()}}return{$numberDouble:Object.is(e,-0)?"-0.0":e.toString()}}if(typeof e=="bigint")return t.relaxed?Number(BigInt.asIntN(64,e)):{$numberLong:BigInt.asIntN(64,e).toString()};if(e instanceof RegExp||ot(e)){let r=e.flags;if(r===void 0){const i=e.toString().match(/[gimuy]*$/);i&&(r=i[0])}return new k(e.source,r).toExtendedJSON(t)}return e!=null&&typeof e=="object"?Fn(e,t):e}const xn={Binary:e=>new A(e.value(),e.sub_type),Code:e=>new v(e.code,e.scope),DBRef:e=>new K(e.collection||e.namespace,e.oid,e.db,e.fields),Decimal128:e=>new j(e.bytes),Double:e=>new W(e.value),Int32:e=>new tt(e.value),Long:e=>f.fromBits(e.low!=null?e.low:e.low_,e.low!=null?e.high:e.high_,e.low!=null?e.unsigned:e.unsigned_),MaxKey:()=>new gt,MinKey:()=>new yt,ObjectId:e=>new L(e),BSONRegExp:e=>new k(e.pattern,e.options),BSONSymbol:e=>new mt(e.value),Timestamp:e=>Y.fromBits(e.low,e.high)};function Fn(e,t){if(e==null||typeof e!="object")throw new c("not an object instance");const r=e._bsontype;if(typeof r>"u"){const n={};for(const i of Object.keys(e)){t.seenObjects.push({propertyName:i,obj:null});try{const o=q(e[i],t);i==="__proto__"?Object.defineProperty(n,i,{value:o,writable:!0,enumerable:!0,configurable:!0}):n[i]=o}finally{t.seenObjects.pop()}}return n}else{if(e!=null&&typeof e=="object"&&typeof e._bsontype=="string"&&e[ct]!==nt)throw new ut;if(Dn(e)){let n=e;if(typeof n.toExtendedJSON!="function"){const i=xn[e._bsontype];if(!i)throw new c("Unrecognized or invalid _bsontype: "+e._bsontype);n=i(n)}return r==="Code"&&n.scope?n=new v(n.code,q(n.scope,t)):r==="DBRef"&&n.oid&&(n=new K(q(n.collection,t),q(n.oid,t),q(n.db,t),q(n.fields,t))),n.toExtendedJSON(t)}else throw new c("_bsontype must be a string, but was: "+typeof r)}}function Ke(e,t){const r={useBigInt64:t?.useBigInt64??!1,relaxed:t?.relaxed??!0,legacy:t?.legacy??!1};return JSON.parse(e,(n,i)=>{if(n.indexOf("\0")!==-1)throw new c(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(n)}`);return qe(i,r)})}function Ge(e,t,r,n){r!=null&&typeof r=="object"&&(n=r,r=0),t!=null&&typeof t=="object"&&!Array.isArray(t)&&(n=t,t=void 0,r=0);const i=Object.assign({relaxed:!0,legacy:!1},n,{seenObjects:[{propertyName:"(root)",obj:null}]}),o=q(e,i);return JSON.stringify(o,t,r)}function jn(e,t){return t=t||{},JSON.parse(Ge(e,t))}function Cn(e,t){return t=t||{},Ke(JSON.stringify(e),t)}wt=Object.create(null);wt.parse=Ke;wt.stringify=Ge;wt.serialize=jn;wt.deserialize=Cn;Object.freeze(wt);function Qt(e,t){try{return O.getNonnegativeInt32LE(e,t)}catch(r){throw new Z("BSON size cannot be negative",t,{cause:r})}}function vt(e,t){let r=t;for(;e[r]!==0;r++);if(r===e.length-1)throw new Z("Null terminator not found",t);return r}function Pn(e,t=0){if(t??=0,e.length<5)throw new Z(`Input must be at least 5 bytes, got ${e.length} bytes`,t);const r=Qt(e,t);if(r>e.length-t)throw new Z(`Parsed documentSize (${r} bytes) does not match input length (${e.length} bytes)`,t);if(e[t+r-1]!==0)throw new Z("BSON documents must end in 0x00",t+r);const n=[];let i=t+4;for(;i<=r+t;){const o=e[i];if(i+=1,o===0){if(i-t!==r)throw new Z("Invalid 0x00 type byte",i);break}const u=i,g=vt(e,i)-u;i+=g+1;let s;if(o===1||o===18||o===9||o===17)s=8;else if(o===16)s=4;else if(o===7)s=12;else if(o===19)s=16;else if(o===8)s=1;else if(o===10||o===6||o===127||o===255)s=0;else if(o===11)s=vt(e,vt(e,i)+1)+1-i;else if(o===3||o===4||o===15)s=Qt(e,i);else if(o===2||o===5||o===12||o===13||o===14)s=Qt(e,i)+4,o===5&&(s+=1),o===12&&(s+=12);else throw new Z(`Invalid 0x${o.toString(16).padStart(2,"0")} type byte`,i);if(s>r)throw new Z("value reports length larger than document",i);n.push([o,u,g,i,s]),i+=s}return n}It=Object.create(null);It.parseToElements=Pn;It.ByteUtils=h;It.NumberUtils=O;Object.freeze(It);const Xe=1024*1024*17;let Q=h.allocate(Xe);Jn=function(e){Q.length<e&&(Q=h.allocate(e))};Hn=function(e,t={}){const r=typeof t.checkKeys=="boolean"?t.checkKeys:!1,n=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,i=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0,o=typeof t.minInternalBufferSize=="number"?t.minInternalBufferSize:Xe;Q.length<o&&(Q=h.allocate(o));const u=Ot(Q,e,r,0,0,n,i,null),g=h.allocateUnsafe(u);return g.set(Q.subarray(0,u),0),g};Vn=function(e,t,r={}){const n=typeof r.checkKeys=="boolean"?r.checkKeys:!1,i=typeof r.serializeFunctions=="boolean"?r.serializeFunctions:!1,o=typeof r.ignoreUndefined=="boolean"?r.ignoreUndefined:!0,u=typeof r.index=="number"?r.index:0,g=Ot(Q,e,n,0,0,i,o,null);return t.set(Q.subarray(0,g),u),u+g-1};Wn=function(e,t={}){return Ze(h.toLocalBufferType(e),t)};Yn=function(e,t={}){t=t||{};const r=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,n=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0;return dt(e,r,n)};kn=function(e,t,r,n,i,o){const u=Object.assign({allowObjectSmallerThanBufferSize:!0,index:0},o),g=h.toLocalBufferType(e);let s=t;for(let S=0;S<r;S++){const y=O.getInt32LE(g,s);u.index=s,n[i+S]=Ze(g,u),s=s+y}return s};let Zn;qn=Object.freeze({__proto__:null,BSONError:c,BSONOffsetError:Z,BSONRegExp:k,BSONRuntimeError:te,BSONSymbol:mt,BSONType:rn,BSONValue:P,BSONVersionError:ut,Binary:A,Code:v,DBRef:K,Decimal128:j,Double:W,EJSON:wt,Int32:tt,Long:f,MaxKey:gt,MinKey:yt,ObjectId:L,Timestamp:Y,UUID:F,calculateObjectSize:Yn,deserialize:Wn,deserializeStream:kn,onDemand:It,serialize:Hn,serializeWithBufferAndIndex:Vn,setInternalBufferSize:Jn});Zn=Object.freeze({__proto__:null})})();export{qn as BSON,c as BSONError,Z as BSONOffsetError,k as BSONRegExp,te as BSONRuntimeError,mt as BSONSymbol,rn as BSONType,P as BSONValue,ut as BSONVersionError,A as Binary,v as Code,K as DBRef,j as Decimal128,W as Double,wt as EJSON,tt as Int32,f as Long,gt as MaxKey,yt as MinKey,L as ObjectId,Y as Timestamp,F as UUID,Yn as calculateObjectSize,Wn as deserialize,kn as deserializeStream,It as onDemand,Hn as serialize,Vn as serializeWithBufferAndIndex,Jn as setInternalBufferSize,__tla};